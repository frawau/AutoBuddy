#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is used to configure an AutoBuddy appliance
#
# Copyright (c) 2015-2017 François Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
import subprocess,os,json,sys,glob,pwd,re,socket

BUDDYLOCATION="/".join(os.path.realpath(__file__).split("/")[:-2])
currentowner=os.stat(BUDDYLOCATION)
username=pwd.getpwuid(currentowner.st_uid)[0]
sys.path.append(BUDDYLOCATION+"/Buddylib")

from collections import defaultdict
from getpass import getpass
import buddylib as bl
from urllib.request import urlopen

debug=False
lobtdevs=["hci0","hci1","hci2","hci3"]
GUIBRIDGETYPE="guibridge"
def passgen():
    from random import shuffle,randrange
    lolet=list("0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ-_*.?")
    for i in range(5):
        shuffle(lolet)
    lolet *= 100
    for i in range(20):
        shuffle(lolet)
    startidx=randrange(len(lolet)-16)
    return "".join(lolet[startidx:startidx+16])

def keygen():
    from random import shuffle,randrange
    lolet=list("0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ`~!@#$%^&*()_+-|\[{]}?/.,<:;")
    for i in range(5):
        shuffle(lolet)
    lolet *= 1000
    for i in range(20):
        shuffle(lolet)
    startidx=randrange(len(lolet)-32)
    return "".join(lolet[startidx:startidx+32])


brokerlocation = "localhost"
#This is basically a linear walk-through the needed settings...
mylocation={"timezone":"Europe/Paris","lat":48.8584,"lon":2.2945,"countryCode":"FR","regionName":"Paris","city":"Paris"}
try:
    mylocation=json.loads(urlopen("http://ip-api.com/json").read().decode())
except:
    pass
remindmeattheend=""
import os
user = os.getenv("SUDO_USER")
if user is None:
    iamsuper = False
else:
    iamsuper = True

os.system('clear')
print("\n\nWelcome to AutoBuddy configuration tool.")
if iamsuper:
    print ("It looks like you are running with root privileges. Good!")
    print ("Be forwarned though, we will be setting your time zone, install some needed")
    print ("packages and will access PostgreSQL by masquerading as user 'postgres'.")
    print ("If you do not want this, or if you think it won't work, get out now and run")
    print ("this config tool as an unpriviledged users.")
else:
    print ("It looks like you are running without root privileges. This means that")
    print ("there will be a number of tasks we will not be able to perform. What we")
    print ("will do is tell you what you  need to do when this config tool is done")
    print ("for AutoBuddy to work smoothly. We will also ask you for the user name and")
    print ("password of a PostgreSQL superusers so we can setup the database")


gotit=False
while not gotit:
    choice = input("\n  Do you want to continue? [yes/no] : ")
    if choice.strip().lower() in ["n", "no", "no way","hell no"]:
        try:
            print ("\nAt your request, we will now perform ritual 切腹. さよなら")
        except:
            print ("\nAt your request, we will now perform ritual seppuku. Sayonara.")
            print ("        BTW, you really should use UTF-8.")
        sys.exit(0)
    elif choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
        gotit=True
    else:
        print ("\nJust answer Yes or No. How difficult is that?")

os.system('clear')
#Starting with time zone
if not iamsuper or not os.path.isfile(BUDDYLOCATION+"/.autobuddyneedconfig"):
    print ("\nWe believe your timezone is %s"%mylocation["timezone"])
    print ("If somehow we got that wrong, please be sure to update your location")
    print ("once you have access to AutoBuddy. In Menu > Configure > System Configuration")
    remindmeattheend+=" Check you location in Menu > Configure > System Configuration\n\n"
else:
    print("\nLet's start by updating your time zone.")
    gotit=False
    while not gotit:
        print ("\n\nOK, me think your time zone is %s"%mylocation["timezone"])
        for x in ["Yes","No"]:
            print("\t %s"%x)
        print()
        choice = input(" Your choice: ")
        try:
            if choice.strip().lower() in ['y',"yes","yay","sure","yep","affirmative"]:
                gotit=True
                choice=mylocation["timezone"]
            elif choice.strip().lower() in ['n','no','nope','nay','negative','wrong']:
                gotit=True
                choice=""
            else:
                raise Exception
        except:
            os.system('clear')
            print ("\n\nInput not recognized. Please pay attention.")

    if not choice:
        print ("\n\nOoops, I got it wrong, my bad! Let's try another way.")
        lotz=subprocess.check_output(["timedatectl", "--no-pager","list-timezones"]).decode()
        tzlist=defaultdict(list)
        for rawzone in lotz.split("\n"):
            if not rawzone:
                continue
            zone=rawzone.split("/")
            if len(zone) == 1:
                tzlist[zone[0]]=None
            else:
                tzlist[zone[0]].append("/".join(zone[1:]))
        lotopz=list(tzlist.keys())
        lotopz.sort()
        os.system('clear')
        gotit=False
        mode="init"
        weredone=False
        while not weredone:
            if mode=="init":
                while not gotit:
                    idx=0
                    print ("\n\nPlease do select the number corresponding to your time zone")
                    for x in lotopz:
                        print ("   %d\t %s"%(idx,x))
                        idx+=1
                    print()
                    choice = input(" Your choice: ")
                    try:
                        choice=int(choice)
                        if choice < 0 or choice >= len(lotopz):
                            raise Exception
                        gotit=True
                    except:
                        os.system('clear')
                        print ("\n\nInput not recognized. Please pay attention.")

            mode="sub"
            os.system('clear')
            topzone=lotopz[choice]
            if tzlist[topzone]:
                #Find more
                sidx=0
                maxidx=10
                gotit=False
                while not gotit:
                    print ("\n\n\nPlease do select the number corresponding to your time zone")
                    idx=0
                    while idx< min(maxidx,len(tzlist[topzone])-sidx):
                        print ("   %d\t %s/%s"%(idx,topzone,tzlist[topzone][sidx+idx]))
                        idx+=1
                    print ("\n\nUse 'b' to go back to the previous screen. 'n' to go to the next one.\n")
                    choice = input(" Your choice: ")
                    try:
                        if choice.strip().lower()=='b':
                            if sidx == 0:
                                mode="init"
                                os.system('clear')
                                break
                            else:
                                sidx-=maxidx
                                os.system('clear')
                        elif choice.strip().lower()=='n':
                            if sidx+maxidx < len(tzlist[topzone]):
                                sidx+=maxidx
                            os.system('clear')
                        else:
                            choice=int(choice)
                            if choice < 0 or choice >= min(maxidx,len(tzlist[topzone])-sidx):
                                raise Exception
                            gotit=True
                            weredone=True
                            choice=topzone+"/"+tzlist[topzone][choice+sidx]
                    except:
                        os.system('clear')
                        print ("Input not recognized. Please pay attention.")


    if debug:
        print ("We got %s"%choice)
    else:
        lotz=subprocess.check_output(["timedatectl", "set-timezone",choice])

    os.system('clear')
    print("\n\n\n\n Time zone was set to %s"%choice)

if not os.path.isfile(BUDDYLOCATION+"/.autobuddyneedconfig"):
    choice = input(" Press '<enter>' to continue")
    os.system('clear')

    if not iamsuper:
        print ("\nAutoBuddy requires a number of packages to be installed in order to work.")
        print ("On a Debian/Ubuntu type of distribution, the following 2 commands should be run:\n")
        print("\tsudo apt -y install postgresql python3-sqlalchemy python3-crypto python3-psycopg2 \\\n\t\t\t\tpython3-ephem python3-dateutil python3-bitstring python3-pip")
        print("\tsudo pip3 install --upgrade aiolifx aioarping aiobtname aioblescan pyalsaaudio aiohttp aiocoap zeroconf aiodns\n")
        remindmeattheend+="\nMake sure the needed packages are installed:\n\n"
        remindmeattheend+="\tsudo apt -y install postgresql python3-sqlalchemy python3-crypto python3-psycopg2 \\\n\t\t\t\tpython3-ephem python3-dateutil python3-bitstring python3-pip"
        remindmeattheend+="\n\tsudo pip3 install -U aiolifx aioarping aiobtname pyalsaaudio zeroconf aiohttp aiocoap aiodns\n\n"
    else:
        print("\n\n\n\nNow we shall install the packages we need... You had better be on Debian with apt for this to work")
        choice = input(" Press '<enter>' to proceed")
        try:
            subprocess.run(["apt","-y","install","postgresql","python3-sqlalchemy","python3-crypto","python3-psycopg2","python3-ephem","python3-dateutil","python3-bitstring"])
            subprocess.run(["pip3","install","--upgrade","aiobtname","aioarping","aiolifx", "aioblescan", "pyalsaaudio", "zeroconf", "aiohttp","aiocoap","aiodns"])
            print("Allright, it looks like we are done.")
        except:
            print("Something wrong just happened....Let's continue anyway. Danger is my middle name")
        choice = input(" Press '<enter>' to continue")
        os.system('clear')
else:
    choice = input(" Press '<enter>' to continue")
    os.system('clear')

    if not iamsuper:
        print ("\nAutoBuddy requires a number of packages to be installed in order to work.")
        print ("On a Debian/Ubuntu type of distribution, the following command should be run:\n")
        print("\tsudo pip3 install --upgrade aiolifx aioarping aiobtname aioblescan pyalsaaudio aiohttp aiocoap zeroconf aiodns\n")
        remindmeattheend+="\nMake sure the needed packages are installed:\n\n"
        remindmeattheend+="\n\tsudo pip3 install -U aiolifx aioarping aiobtname pyalsaaudio zeroconf aiohttp aiocoap aiodns\n\n"
    else:
        print("\n\n\n\nNow we shall install/update the packages we need.")
        choice = input(" Press '<enter>' to proceed")
        try:
            subprocess.run(["pip3","install","--upgrade","aiobtname","aioarping","aiolifx", "aioblescan", "pyalsaaudio", "zeroconf", "aiohttp","aiocoap","aiodns"])
            print("Allright, it looks like we are done.")
        except:
            print("Something wrong just happened....Let's continue anyway. Danger is my middle name")
        choice = input(" Press '<enter>' to continue")
        os.system('clear')

print("\n\n\n\nNow we shall install all the bits needed and packaged in a tar file.")
choice = input(" Press '<enter>' to proceed")
try:
    subprocess.run(["tar","xvfj",BUDDYLOCATION+"/alltherest.tar.bz2","-C", BUDDYLOCATION])
    print("Allright, it looks like we are done.")
except:
    print("Something wrong just happened....Let's continue anyway. Danger is my middle name")

if iamsuper and os.path.isfile(BUDDYLOCATION+"/.autobuddyneedconfig"):
    try:
        chpass=subprocess.Popen(["find",BUDDYLOCATION,"-exec","chown", "%d"%currentowner.st_uid+":"+"%d"%currentowner.st_gid, "{}",";"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
    except:
        print("Could not change ownership of untarred files.")


choice = input(" Press '<enter>' to continue")
os.system('clear')
if os.path.isfile(BUDDYLOCATION+"/.autobuddyneedconfig"):
    weredone=False
    newpasswd=""
    while not weredone:
        print ("\n\n\n We will now set a new password for the default user 'autobuddy'.\n\n")
        passwd = getpass(" Password: ")
        confirm = getpass(" Confirm Password: ")
        if passwd == confirm :
            weredone = True
            newpasswd=passwd
        else:
            os.system('clear')
            print ("\n\n The passwords did not match.")

    if debug:
        print ("New password is %d"%newpasswd)
    else:
        chpass=subprocess.Popen(["chpasswd"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
        d_out=chpass.communicate(input="autobuddy:%s"%newpasswd)[0]

    os.unlink(BUDDYLOCATION+"/.autobuddyneedconfig")
    os.system('clear')

    print ("\n\n\n\n Password was set.\n\n")

mainstation = True
print("\nBefore we really start, I have an important question.")
gotit=False
while not gotit:
    print ("\n\nIs this the main AutoBuddy installation? There can only be\none ControlBuddy instance. Is this it?")
    for x in ["Yes","No"]:
        print("\t %s"%x)
    print()
    choice = input(" Your choice: ")
    try:
        if choice.strip().lower() in ['y',"yes","yay","sure","yep","affirmative"]:
            gotit=True
        elif choice.strip().lower() in ['n','no','nope','nay','negative','wrong']:
            gotit=True
            mainstation = False
        else:
            raise Exception
    except:
        os.system('clear')
        print ("\n\nInput not recognized. Please pay attention.")


if mainstation:
    if not iamsuper:
        choice = input(" Press '<enter>' to continue")
        psqldbok=False
        psqluser=None
        print ("\nWe now need to setup PostgreSQL, create a database and 2 users.")
        print ("If you want I can perform these operation but I need a username and password with adequate permissions.")
        print ("\nWould you like to setup the database by providing a user name and password?")
        gotit=False
        while not gotit:
            choice = input("\n Your choice? [yes/no] : ")
            if choice.strip().lower() in ["n", "no", "no way","hell no"]:
                gotit=True
                print("Ok, we'll tell you what needs to be done.")
            elif choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
                gotit=True
                psqldbok=True
                psqluser=input("\n Please input the username : ")
                psqlpasswd=input("\n Please input the password : ")
                print("Ok, we'll use user %s with password %s"%(psqluser,psqlpasswd))
                my_env = os.environ.copy()
                my_env["PGUSER"] = psqluser
                my_env["PGPASSWORD"] = psqlpasswd
            else:
                print ("Just answer Yes or No. How difficult is that?")
    else:
        psqldbok=True
        psqluser=None



    createdb="CREATE DATABASE autobuddy ENCODING 'UTF8';"
    pgreadonlyuser="""
    CREATE USER readbuddy WITH ENCRYPTED PASSWORD '%s';
    GRANT CONNECT ON DATABASE autobuddy TO readbuddy;
    GRANT USAGE ON SCHEMA public TO readbuddy;
    GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO readbuddy;
    GRANT SELECT ON ALL TABLES IN SCHEMA public to readbuddy;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON SEQUENCES TO readbuddy;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readbuddy;
    """
    pgmainuser="""
    CREATE USER autobuddy WITH ENCRYPTED PASSWORD '%s';
    GRANT ALL PRIVILEGES ON DATABASE autobuddy TO autobuddy;
    """
    xx=input("\n Press <enter> to continue...")
    os.system('clear')
    weredone=False
    newpasswd=""
    while not weredone:
        print ("\n\n\n We will now define a password for the \"autobuddy\"  user in PostgreSQL.\n This user has all access to the \"autobuddy\" database.\n\n")
        print (" If you leave the password empty, I will generate the password automatically.\n\n")
        passwd = getpass(" Password: ")
        if passwd:
            confirm = getpass(" Confirm Password: ")
            if passwd == confirm :
                weredone = True
                dbpasswd=passwd
            else:
                os.system('clear')
                print ("\n\n The passwords did not match.")
        else:
            dbpasswd=passgen()
            weredone = True


    weredone=False
    newpasswd=""
    while not weredone:
        print ("\n\n\n We will now define a password for the \"readbuddy\"  user in PostgreSQL.\n This user has read-only access to the \"autobuddy\" database.\n\n")
        print (" If you leave the password empty, I will generate the password automatically.\n\n")
        passwd = getpass(" Password: ")
        if passwd:
            confirm = getpass(" Confirm Password: ")
            if passwd == confirm :
                weredone = True
                ropasswd=passwd
            else:
                os.system('clear')
                print ("\n\n The passwords did not match.")
        else:
            ropasswd=passgen()
            weredone = True

    if psqldbok:
        newconfig=createdb+pgmainuser%dbpasswd + pgreadonlyuser%ropasswd
        if debug:
            print ("New passwords are {} and {}.".format(dbpasswd,ropasswd))
        else:
            if psqluser:
                sqlproc=subprocess.Popen(["/usr/bin/psql"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True,env=my_env)
            else:
                sqlproc=subprocess.Popen(["sudo", "-u", "postgres", "/usr/bin/psql"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
            d_out=sqlproc.communicate(input=newconfig)

        os.system('clear')
        print("\n\n\n\n Database was created, so were users and passwords were set.\n\n")
        choice = input(" Press '<enter>' to continue")
    else:
        remindmeattheend+="You need to create database and users with:\n"
        remindmeattheend+=createdb+"\n"
        remindmeattheend+=pgmainuser%dbpasswd + pgreadonlyuser%ropasswd

    os.system('clear')
    print ("\n\n\n\n I need to know the name of the top zone.\n\n")
    choice = input(" Top Zone Name [Home]: ")
    if not choice:
        topzone="Home"
    else:
        topzone=choice

    os.system('clear')
    print ("\n\n\n\nSince we are on the main station, we will also be running the rules engine.")
    print ("One of the possible action is to push notification via email.")
    print ("In order for this to work, we need some information.")

    print ("\n I need to know the SMTP (Email) server, a host name or an IP address. \n\n")
    choice=None
    regex = re.compile(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
    actionsmtp=None
    actionsender=None
    actionsmtpuser=None
    actionsmtppasswd=None
    while not choice:
        choice=input("SMTP server (\"localhost\") => ").strip()
        if choice=="":
            actionsender="root"
            actionsmtp="localhost"
        else:
            result = regex.match(choice)
            if not result:
                try:
                    address = socket.gethostbyname(choice)
                except:
                    print("{} is not a known hostname".format(choice))
                    choice=None
            else:
                try:
                    socket.inet_aton(choice)
                    print("Got an IP address")
                except:
                    print("{} is not a valid IP address".format(choice))
                    choice=None
    if actionsender is None:
        actionsmtp = choice
        print ("\n Email need a sender, in many cases this must be a real user. \n\n")
        choice=input("Sender (\"root\") => ").strip()
        if choice=="":
            actionsender="root"
        else:
            actionsender=choice
        print ("\n OK, we will use \"{}\" as sender. \n\n".format(actionsender))
        print ("\n Some SMTP servers require authentication, if that is the case, we need a user and password. \n\n")
        choice=input("SMTP authentication user (no authentication) => ").strip()
        if choice:
            actionsmtpuser=choice
            choice=None
            while choice is None:
                choice=input("SMTP authentication password => ").strip()
                if choice == "":
                    choice=None
                    print(" Please enter a password.")
            actionsmtppasswd = choice
            print("\n OK, we will authenticate as {] with password {}".format(actionsmtpuser,actionsmtppasswd))
        else:
            print("\n OK, we will not use authentication")
    else:
        print ("\nOK, we will use \"localhost\" and \"root\" as sender. \n\n")



else:
    print ("\n\nSince this is a peripheral station, we need to know where the main station is\nand we need to know the credential to use.")
    print ("\nWhat is the host bane or IP address of the device running ControlBuddy?")
    choice=None
    regex = re.compile(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
    while not choice:
        choice=input("ControlBuddy host => ").strip()
        result = regex.match(choice)
        if not result:
            try:
                address = socket.gethostbyname(choice)
            except:
                print("{} is not a known hostname".format(choice))
                choice=None
        else:
            try:
                socket.inet_aton(choice)
                print("Got an IP address")
            except:
                print("{} is not a valid IP address".format(choice))
                choice=None
    brokerlocation=choice
    os.system('clear')
    print ("\nOK, we contact ControlBuddy at {}.".format(brokerlocation))
    print ("\nNow we need to know the credential to use. The credential was generated when you installed")
    print ("ControlBuddy. You can also retrieve it from any of the config files on the main station (e.g. in AutoBuddy/.buddyconfig/config.cfg)")
    choice=""
    while not choice:
        choice=input("Credential => ").strip()
        if not choice:
            print("You need to type something!")
    credential=choice
    print ("OK, using \"{}\" for credential.".format(credential))
    print ("\n\nIMPORTANT: You will need to copy the SSL certificate from the main device to {}".format(BUDDYLOCATION+"/.tls\n\n"))

dolifx = False
doflic = False
dovoice = False
dopresence = False
dopresencelan = False
dopresencebt = False
dokodi = False
doscanner = False
doblescan = False
dologger = False
dothingsboard = False
doi2c = False

print("Finaly, we need to know which optional modules you want to run.")
print("\n\nLifxBuddy allows you to control your Lifx LED bulbs.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    dolifx=True

print("\n\nPresenceBuddy allows you to detect people's presence by monitoring their devices")
print("(like smartphone) over LAN and/or over Bluetooth.")
choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    dopresence=True

if dopresence:
    choice = input("\n  Do you want to use ARPing over the LAN for presence (not recommended)? [yes/NO] : ")
    if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
        dopresencelan=True
    else:
        dopresencelan=False
    choice = input("\n  Do you want to use Bluetooth for  presence (recommended)? [yes/NO] : ")
    if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
        dopresencebt=lobtdevs[0]
        lobtdevs=lobtdevs[1:]
    else:
        dopresencelan=False

print("\n\nFlicBuddy allows you to receive click event from your flic buttons.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    doflic=lobtdevs[0]
    lobtdevs=lobtdevs[1:]

print("\n\nVoiceBuddy allows you configure voice commands.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    dovoice=True

voicedev="default"
if dovoice:
    import alsaaudio
    gotit = False
    while not gotit:
        print (" Please select the audio device to use for listening.")
        lastdev = 0
        for dnb,dname in enumerate(alsaaudio.cards()):
            print ("   %d\t %s"%(dnb,dname))
            lastdev = dnb
        choice = input("Your choice: ")
        try:
            choice=int(choice)
            if choice >= 0  and choice <= lastdev:
                gotit = True
                voicedev = "plughw:%d,0"%choice
            else:
                os.system('clear')
                print ("\nInput must be an integer between 0 and %d!"%lastdev)
        except:
            os.system('clear')
            print ("\nInput must be an integer!")

print("\n\nKodiBuddy allows you to control your Kodi instances.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    dokodi=True
    doscanner=True

print("\n\nBLEBuddy allows you to scan for BLE advertised information.\nYou will need to select which plugin to use in the GUI.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    doblescan=True

print("\n\nLoggerBuddy let you record events over time. They can then be graphed using the GUI.\nNote that this will use a local SQLite database file.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    dologger=True

print("\n\nThingsBuddy let you log events over time and states. They can then be graphed at ThingsBoard.io.\nNote that this requires Internet access.")

choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    dothingsboard=True

print("\n\nI2CBuddy let you generate measurments from some I2C sensors.")

try:
    lotz=subprocess.check_output(["i2cdetect", "-l"]).decode()
    i2cbus = int(lotz[:lotz.index("\t")].split("-")[1])
except:
    i2cbus = 1
i2csubtype = "i2csensor"
choice = input("\n  Do you want to run it? [yes/NO] : ")
if choice.strip().lower() in ["y", "ye", "yes","let's do this","ok"]:
    doi2c=True

    print (" I need to know what is your I2C bus number. I tried to guess it."
    print (" Please select the audio device to use for listening.")

    choice = input("Your choice [%d]: "%i2cbus)
    if choice.strip():
        while True:
            try:
                choice=int(choice)
                if choice >= 0:
                    i2cdev = choice
                    break
                else:
                    os.system('clear')
                    print ("\nInput must be a positive integer!")
            except:
                os.system('clear')
                print ("\nInput must be an integer!")

                print (" I also need to know what name you would like to give to this sensor. It should be unique across all sensors.")
    choice = input("Sensor name [%s] : "%i2csubtype)
    if choice.strip():
        i2csubtype = choice.strip()


#Let's summarize
print("\nYou have decided:")
if dolifx:
    print("\tto run LifxBuddy")
else:
    print("\tnot to run LifxBuddy")

if dopresence and (dopresencebt or dopresencelan):
    if dopresencebt and dopresencelan:
        print("\tto run PresenceBuddy over LAN and Bluetooth")
    elif dopresencebt:
        print("\tto run PresenceBuddy over Bluetooth")
    else:
        print("\tto run PresenceBuddy over LAN")
else:
    print("\tnot to run PresenceBuddy")

if doflic:
    print("\tto run FlicBuddy")
else:
    print("\tnot to run FlicBuddy")

if dovoice:
    print("\tto run VoiceBuddy with {}".format(voicedev))
else:
    print("\tnot to run VoiceBuddy")

if dokodi:
    print("\tto run KodiBuddy")
else:
    print("\tnot to run KodiBuddy")

if doblescan:
    print("\tto run BLEBuddy")
else:
    print("\tnot to run BLEBuddy")

if dologger:
    print("\tto run LoggerBuddy")
else:
    print("\tnot to run LoggerBuddy")

if dothingsboard:
    print("\tto run ThingsBoardBuddy")
else:
    print("\tnot to run ThingBoardBuddy")

if doi2c:
    print("\tto run I2CBuddy")
else:
    print("\tnot to run I2CBuddy")


if doflic and dopresencebt:
    print("\nNote: Given you are using both BuddyFlic and using Bluetooth for presence, you must have 2 Bluetooth adapters.\n")
print ("\n\n\n\n Thank you, I will now proceed and finalize the configuration.\n\n")
choice = input(" Press '<enter>' to continue")

certdir=BUDDYLOCATION+"/.tls"

try:
    os.mkdir(certdir,mode=0o700)
except FileExistsError:
    pass

os.chown(certdir,currentowner.st_uid,currentowner.st_gid)

try:
    os.mkdir(BUDDYLOCATION+"/.buddyconfig",mode=0o700)
except FileExistsError:
    pass

os.chown(BUDDYLOCATION+"/.buddyconfig",currentowner.st_uid,currentowner.st_gid)

try:
    os.mkdir(BUDDYLOCATION+"/.run",mode=0o700)
except FileExistsError:
    pass

os.chown(BUDDYLOCATION+"/.run",currentowner.st_uid,currentowner.st_gid)


if mainstation:
    subj="/C=%s/ST=%s/L=%s/O=AutoBuddy Security/OU=Home Security/CN=autobuddy.local"%(mylocation["countryCode"],mylocation["regionName"],mylocation["city"])

    subprocess.run(["openssl", "req", "-x509", "-nodes", "-days", "7300", "-newkey", "rsa:2048", "-keyout", BUDDYLOCATION+"/.tls/autobuddy.key", "-out",
                    BUDDYLOCATION+"/.tls/autobuddy.crt", "-subj", subj])
    print("Self-signed certificate was created")

    os.chown(BUDDYLOCATION+"/.tls/autobuddy.key",currentowner.st_uid,currentowner.st_gid)
    os.chmod(BUDDYLOCATION+"/.tls/autobuddy.key",0o600)
    os.chown(BUDDYLOCATION+"/.tls/autobuddy.crt",currentowner.st_uid,currentowner.st_gid)
    os.chmod(BUDDYLOCATION+"/.tls/autobuddy.crt",0o600)

    credential=passgen()
    print ("Credential will be {}.".format(credential))
    mycfg={}
    mycfg["zone"]=topzone
    mycfg["database"] = {"db": "autobuddy", "host": "localhost", "driver": "postgres", "user": "autobuddy","password":dbpasswd}
    mycfg["dbronly"] = {"user": "readbuddy","password":ropasswd}
    mycfg["type"] = "control"
    mycfg["credential"] = credential
    mycfg["ssl"]=certdir
    mycfg["buddykey"] = keygen()

    controlkey=mycfg["buddykey"]

    fn=BUDDYLOCATION+"/.buddyconfig/config.cfg"
    with open(fn,"w") as cfile:
        json.dump(mycfg,cfile)
    os.chmod(fn,0o600)
    os.chown(fn,currentowner.st_uid,currentowner.st_gid)
    os.chmod(BUDDYLOCATION+"/ControlBuddy/ControlBuddy",0o775)
    mycmd="""#!/bin/bash
    export PYTHONPATH="""
    mycmd+=BUDDYLOCATION+"/Buddylib"
    mycmd+="""
    while [ 1 ]; do
    """
    mycmd+=BUDDYLOCATION+"/ControlBuddy/ControlBuddy -c "+fn
    mycmd+="\nsleep 10\ndone\n"
    fn=BUDDYLOCATION+"/.run/01-control"
    with open(fn,"w") as cfile:
        cfile.write(mycmd)
    os.chown(fn,currentowner.st_uid,currentowner.st_gid)
    os.chmod(fn,0o750)
    bustartcmd="#!/bin/bash\n    tmux new-session -s AutoBuddy -n ControlBuddy -d "+fn

    print ("Still working!")

    mycfg={}
    mycfg["tls"]=certdir
    mycfg["ssl"]=certdir
    mycfg["buddykey"] = keygen()
    mycfg["application"] = BUDDYLOCATION+"/WebBuddy/buddyctrl.html"
    mycfg["host"] = "*"
    mycfg["port"] = 8090
    mycfg["type"] = GUIBRIDGETYPE
    mycfg["broker"] = brokerlocation
    mycfg["credential"] = credential
    socketkey = mycfg["buddykey"]

    fn=BUDDYLOCATION+"/.buddyconfig/websocket.cfg"
    with open(fn,"w") as cfile:
        json.dump(mycfg,cfile)
    os.chmod(fn,0o600)
    os.chown(fn,currentowner.st_uid,currentowner.st_gid)
    os.chmod(BUDDYLOCATION+"/SocketBuddy/SocketBuddy",0o775)
    mycmd="""#!/bin/bash
    export PYTHONPATH="""
    mycmd+=BUDDYLOCATION+"/Buddylib"
    mycmd+="""
    while [ 1 ]; do
    sleep 25
    """
    mycmd+=BUDDYLOCATION+"/SocketBuddy/SocketBuddy -c "+fn
    mycmd+="\ndone\n"
    fn=BUDDYLOCATION+"/.run/99-socket"
    with open(fn,"w") as cfile:
        cfile.write(mycmd)
    os.chown(fn,currentowner.st_uid,currentowner.st_gid)
    os.chmod(fn,0o750)
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n SocketBuddy "+fn

    print ("Still working!")
else: #Auxillary station
    bustartcmd="#!/bin/bash\n    tmux new-session -s AutoBuddy -n Buddy -d sleep 30"

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "light"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()

fn=BUDDYLOCATION+"/.buddyconfig/lifx.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/LifxBuddy/LifxBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 20
"""
mycmd+=BUDDYLOCATION+"/LifxBuddy/LifxBuddy -c "+fn
mycmd+="\nsleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/30-lifx"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if dolifx:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n LifxBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n LifxBuddy "+fn

print ("Patience!")


mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "switch"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
mycfg["flichost"] = "localhost"
mycfg["flicpath"] = BUDDYLOCATION + "/FlicBuddy/flicd/"
mycfg["btiface"] = doflic or "hci0"

fn=BUDDYLOCATION+"/.buddyconfig/flic.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/FlicBuddy/FlicBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 20
"""
mycmd+=BUDDYLOCATION+"/FlicBuddy/FlicBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/30-flic"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if doflic:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n FlicBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n FlicBuddy "+fn

print ("Just a little longer!")

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "mediaplayer"
mycfg["subtype"] = "Kodi"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["scanner"]="scanner.ipservices"
mycfg["buddykey"] = keygen()

fn=BUDDYLOCATION+"/.buddyconfig/kodi.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/KodiBuddy/KodiBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 22
"""
mycmd+=BUDDYLOCATION+"/KodiBuddy/KodiBuddy -c "+fn
mycmd+="\nsleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/30-kodi"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if dokodi:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n KodiBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n KodiBuddy "+fn



mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "scanner"
mycfg["subtype"] = "ipservices"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()

fn=BUDDYLOCATION+"/.buddyconfig/scanner.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/ScannerBuddy/ScannerBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 25
"""
mycmd+=BUDDYLOCATION+"/ScannerBuddy/ScannerBuddy -c "+fn
mycmd+="\nsleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/60-scanner"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if doscanner:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n ScannerBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n ScannerBuddy "+fn

print ("Just a teeny weeny little longer!")

if mainstation:
    mycfg={}
    mycfg["host"]= brokerlocation
    mycfg["type"] = "action"
    mycfg["credential"] = credential
    mycfg["ssl"]=certdir
    mycfg["buddykey"] = keygen()
    mycfg["smtp"] = actionsmtp
    mycfg["sender"] = actionsender
    mycfg["user"] = actionsmtpuser or ""
    mycfg["password"] = actionsmtppasswd or ""
    mycfg["restricted"] = GUIBRIDGETYPE
    actionkey=mycfg["buddykey"]
    fn=BUDDYLOCATION+"/.buddyconfig/action.cfg"
    with open(fn,"w") as cfile:
        json.dump(mycfg,cfile)
    os.chmod(fn,0o600)
    os.chown(fn,currentowner.st_uid,currentowner.st_gid)
    os.chmod(BUDDYLOCATION+"/ActionBuddy/ActionBuddy",0o775)
    mycmd="""#!/bin/bash
    export PYTHONPATH="""
    mycmd+=BUDDYLOCATION+"/Buddylib"
    mycmd+="""
    while [ 1 ]; do
    sleep 20
    """
    mycmd+=BUDDYLOCATION+"/ActionBuddy/ActionBuddy -c "+fn
    mycmd+="\n    sleep 2\ndone\n"
    fn=BUDDYLOCATION+"/.run/50-action"
    with open(fn,"w") as cfile:
        cfile.write(mycmd)
    os.chown(fn,currentowner.st_uid,currentowner.st_gid)
    os.chmod(fn,0o750)
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n ActionBuddy "+fn

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "presence"
mycfg["subtype"] = "mac"
if dopresence and dopresencelan:
    mycfg["lan"] = "true"
else:
    mycfg["lan"] = "false"
if dopresencebt:
    mycfg["btdev"] = int(dopresencebt[-1])
elif not dopresence:
    mycfg["btdev"] = 0

mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
actionkey=mycfg["buddykey"]
fn=BUDDYLOCATION+"/.buddyconfig/presence.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/PresenceBuddy/PresenceBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 30
"""
mycmd+=BUDDYLOCATION+"/PresenceBuddy/PresenceBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/50-presence"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if dopresence:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n PresenceBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n PresenceBuddy "+fn

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "voice"
mycfg["subtype"] = "main"

mycfg["modeldir"] = "/usr/share/pocketsphinx/model/en-us/en-us"
mycfg["voicepath"] = BUDDYLOCATION+"/VoiceBuddy/"
mycfg["mic"] = voicedev

mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
fn=BUDDYLOCATION+"/.buddyconfig/voice.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/VoiceBuddy/VoiceBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 10
"""
mycmd+=BUDDYLOCATION+"/VoiceBuddy/VoiceBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/50-voice"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if dovoice:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n VoiceBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n VoiceBuddy "+fn

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "sensor"
mycfg["subtype"] = "blesensor"
if doblescan:
    mycfg["btdev"] = int(lobtdevs[0][-1])
    lobtdevs=lobtdevs[1:]
else:
    mycfg["btdev"] = 0

mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
fn=BUDDYLOCATION+"/.buddyconfig/blescan.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/BLEBuddy/BLEBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
sleep 30
while [ 1 ]; do
sleep 30
"""
mycmd+=BUDDYLOCATION+"/BLEBuddy/BLEBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/50-blescan"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if doblescan:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n BLEBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n BLEBuddy "+fn


mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "logger"
mycfg["subtype"] = "sqlite"
mycfg["dbfile"] = BUDDYLOCATION+"/LoggerBuddy/logger.sqlite"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
fn=BUDDYLOCATION+"/.buddyconfig/logger.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/LoggerBuddy/LoggerBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 30
"""
mycmd+=BUDDYLOCATION+"/LoggerBuddy/LoggerBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/70-logger"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if dologger:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n LoggerBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n LoggerBuddy "+fn

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "logger"
mycfg["subtype"] = "thingsboard"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
mycfg["restricted"] = GUIBRIDGETYPE
fn=BUDDYLOCATION+"/.buddyconfig/thingsboard.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/ThingsBoardBuddy/ThingsBoardBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 30
"""
mycmd+=BUDDYLOCATION+"/ThingsBoardBuddy/ThingsBoardBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/70-thingsboard"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if dothingsboard:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n ThingsBoardBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n ThingsBoardBuddy "+fn

mycfg={}
mycfg["host"]= brokerlocation
mycfg["type"] = "sensor"
mycfg["subtype"] = i2csubtype
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
mycfg["i2cbus"] = i2cbus
fn=BUDDYLOCATION+"/.buddyconfig/i2csensor.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/I2CBuddy/I2CBuddy",0o775)
mycmd="""#!/bin/bash
export PYTHONPATH="""
mycmd+=BUDDYLOCATION+"/Buddylib"
mycmd+="""
while [ 1 ]; do
sleep 25
"""
mycmd+=BUDDYLOCATION+"/I2CBuddy/I2CBuddy -c "+fn
mycmd+="\n    sleep 7\ndone\n"
fn=BUDDYLOCATION+"/.run/80-i2csensor"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
if doi2c:
    bustartcmd+="\n    tmux new-window -t AutoBuddy -d -n I2CBuddy "+fn
else:
    bustartcmd+="\n    #tmux new-window -t AutoBuddy -d -n I2CBuddy "+fn



fn=BUDDYLOCATION+"/.start-autobuddy"
with open(fn,"w") as cfile:
    cfile.write(bustartcmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)


if mainstation:
    mycfg["database"] = {"db": "autobuddy", "host": "localhost", "driver": "postgres", "user": "autobuddy","password":dbpasswd}

    bdb = mycfg["database"]["driver"] + "://"
    if "user" in mycfg["database"] and mycfg["database"]["user"]:
        bdb += mycfg["database"]["user"] + ":" + mycfg["database"]["password"] + "@"
    bdb += mycfg["database"]["host"]

    if "port" in mycfg["database"] and mycfg["database"]["port"]:
        bdb += ":"+ str(mycfg["database"]["port"])
    bdb += "/" + mycfg["database"]["db"]

    print ("Almost there!")
    if psqldbok:
        #print "Connecting with",bdb
        sess=bl.getSession(bdb)
        bl.initialize(sess)
        nzone=bl.Zone()
        nzone.name="zone-BuddyRoot"
        nzone.nickname=topzone
        sess.add(nzone)
        nprop=bl.BuddyProperty()
        nprop.entity=GUIBRIDGETYPE
        nprop.name="users"
        nprop.values=bl.encrypt({"admin":["password","admin"]},socketkey)
        sess.add(nprop)
        nprop=bl.BuddyProperty()
        nprop.entity="System"
        nprop.name="configuration"
        nprop.values=bl.encrypt({"location":{"longitude":mylocation["lon"],"latitude":mylocation["lat"],"altitude":4}},controlkey)
        sess.add(nprop)
        nprop=bl.BuddyProperty()
        nprop.entity="action"
        nprop.name="rules"
        nprop.values=bl.encrypt({},actionkey)
        sess.add(nprop)
        nprop=bl.BuddyProperty()
        nprop.entity="action"
        nprop.name="state variable"
        nprop.values=bl.encrypt({},actionkey)
        sess.add(nprop)
        sess.commit()


    #Bloddy grant select!
    newconfig="""GRANT SELECT ON TABLE device TO readbuddy;
    GRANT SELECT ON TABLE zone TO readbuddy;
    """
    if psqldbok:
        if psqluser:
            sqlproc=subprocess.Popen(["/usr/bin/psql","autobuddy"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True,env=my_env)
        else:
            chpass=subprocess.Popen(["sudo", "-u", "postgres", "/usr/bin/psql","autobuddy"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
        d_out=chpass.communicate(input=newconfig)

if not iamsuper:
    remindmeattheend+="\nYou must permit access to bluetooth adapter with:\n"

for fname in glob.glob(BUDDYLOCATION + "/FlicBuddy/flicd/flicd.*") :
    if iamsuper:
        subprocess.run(["/sbin/setcap", "cap_net_admin=ep", fname])
        subprocess.run(["/sbin/setcap", "cap_net_bind_service=+ep", "/usr/bin/python3.5"])
        subprocess.run(["/sbin/setcap", "cap_net_raw=+ep", "/usr/bin/python3.5"])
    else:
        remindmeattheend+="\tsudo /sbin/setcap cap_net_admin=ep" + fname +"\n"
        remindmeattheend+="\tsudo /sbin/setcap 'cap_net_bind_service=+ep' /usr/bin/python3.5\n"
        remindmeattheend+="\tsudo /sbin/setcap 'cap_net_raw=+ep' /usr/bin/python3.5\n"

if mainstation:
    if not psqldbok:
        remindmeattheend+="\n\nAfter creating the database you will also need to run the python script to bootstrap that database:\n\n"
        remindmeattheend+="import sys\n"
        remindmeattheend+="sys.path.append(\"%s\")\n"%(BUDDYLOCATION+"/Buddylib")
        remindmeattheend+="import buddylib as bl\n"
        remindmeattheend+="sess=bl.getSession(\"%s\")\n"%bdb
        remindmeattheend+="bl.initialize(sess)\n"
        remindmeattheend+="nzone=bl.Zone()\n"
        remindmeattheend+="nzone.name=\"zone-BuddyRoot\"\n"
        remindmeattheend+="nzone.nickname=topzone\n"
        remindmeattheend+="sess.add(nzone)\n"
        remindmeattheend+="nprop=bl.BuddyProperty()\n"
        remindmeattheend+="nprop.entity=\""+GUIBRIDGETYPE+"\"\n"
        remindmeattheend+="nprop.name=\"users\"\n"
        remindmeattheend+="nprop.values=bl.encrypt({\"admin\":[\"password\",\"admin\"]},\"%s\")\n"%socketkey
        remindmeattheend+="sess.add(nprop)\n"
        remindmeattheend+="nprop=bl.BuddyProperty()\n"
        remindmeattheend+="nprop.entity=\"System\"\n"
        remindmeattheend+="nprop.name=\"configuration\"\n"
        remindmeattheend+="nprop.values=bl.encrypt({\"location\":{\"longitude\":%.8f,\"latitude\":%.8f,\"altitude\":4}},\"%s\")\n"%(mylocation["lon"],mylocation["lat"],controlkey)
        remindmeattheend+="sess.add(nprop)\n"
        remindmeattheend+="nprop=bl.BuddyProperty()\n"
        remindmeattheend+="nprop.entity=\"action\"\n"
        remindmeattheend+="nprop.name=\"rules\"\n"
        remindmeattheend+="nprop.values=bl.encrypt({},\"%s\")\n"%actionkey
        remindmeattheend+="sess.add(nprop)\n"
        remindmeattheend+="nprop=bl.BuddyProperty()\n"
        remindmeattheend+="nprop.entity=\"action\"\n"
        remindmeattheend+="nprop.name=\"state variable\"\n"
        remindmeattheend+="nprop.values=bl.encrypt({},\"%s\")\n"%actionkey
        remindmeattheend+="sess.add(nprop)\n"
        remindmeattheend+="sess.commit()\n"
        remindmeattheend+="\n\n"

    if not psqldbok:
        remindmeattheend+="\nAfter that, you need to connect to the database again and do:"
        remindmeattheend+="\n"+newconfig+"\n"
#Update in BuddyTools
for fn in os.listdir(BUDDYLOCATION+"/BuddyTools"):
    with open(BUDDYLOCATION+"/BuddyTools/"+fn, 'r') as file :
        filedata = file.read()
        # Replace the target string
        for val,newval in [("<AUTOBUDDYHOST/>",os.uname()[1]),
                        ("<AUTOBUDDYPORT/>","8745"),
                        ("<AUTOBUDDYCREDENTIAL/>",credential)]:
            filedata = filedata.replace(val, newval)

    with open(BUDDYLOCATION+"/BuddyTools/"+fn, 'w') as file :
        file.write(filedata)

try:
    systemdfile="""
[Unit]
Description=AutoBuddy Start/Stop
Wants=network-online.target
After=network-online.target

[Service]
Type=oneshot
RemainAfterExit=true
ExecStart="""
    systemdfile+=BUDDYLOCATION+"/.start-autobuddy\n"
    systemdfile+="ExecStop="+BUDDYLOCATION+"/.stop-autobuddy\n"
    systemdfile+="""
[Install]
WantedBy=multi-user.target
"""
    if iamsuper:
        with open("/etc/systemd/system/autobuddy.service","w") as cfile:
            cfile.write(systemdfile)
        chpass=subprocess.Popen(["systemctl", "enable", "autobuddy"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
        print ("\n\n\n\n We are done.\n")
        if mainstation:
            print("After reboot, point your browser to https://autobuddy.local:8090/.\n\n Login with username \"admin\" and password \"password\".")
    else:
        remindmeattheend+="\n\nIn order for AutoBuddy to start automatically after a reboot, must create a file:\n"
        remindmeattheend+="\t/etc/systemd/system/autobuddy.service\ncontaining the following:\n\n"
        remindmeattheend+=systemdfile
        remindmeattheend+="\n\nThen you should enable it with:\n\t\tsystemctl enable autobuddy\n"
        print ("\n\n\n\n We are almost done... See below for what still needs to be done.\n\n After reboot, point your browser to https://autobuddy.local:8090/.\n\n Login with username \"admin\" and password \"password\".")

    #choice = input(" Press '<enter>' to reboot")
    #os.system("reboot")
except:
    remindmeattheend+="\n\nIn order for AutoBuddy to start automatically after a reboot, must create a file:\n"
    remindmeattheend+="\t/etc/systemd/system/autobuddy.service\ncontaining the following:\n\n"
    remindmeattheend+=systemdfile
    remindmeattheend+="\n\nThen you should enable it with:\n\t\tsystemctl enable autobuddy\n"
    print ("\n\n\n\n We are almost done... See below for what still needs to be done.\n\n After reboot, point your browser to https://autobuddy.local:8090/.\n\n Login with username \"admin\" and password \"password\".")
    print ("\nIf you plan to connect remote buddies, you'll need enable remote access to PostgreSQL\nand use the credential {}".format(credential))

if remindmeattheend:
    print("\n\nHere is a reminder of what you still need to do before you can reboot:")
    print(remindmeattheend)

print ("\nIf you plan to connect remote buddies, you'll need enable remote access to PostgreSQL\nand use the credential {}".format(credential))
