#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Shelly lightes
#
# Copyright © 2021 François Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import sys
import logging
import random
import datetime as dt

import buddylib as bl
import asyncio as aio
from functools import reduce


SUBTYPE = "shelly"
CERTFILE = "autobuddy.crt"
DEVLIST = ["shellydw-"]
BUILDNAME = "ShellyFake"
__version__ = "1.0"


TIMEOUT = 40

_log = logging.getLogger(__name__)


class ShellyS(bl.sensor, bl.BuddyDeviceMQTT):
    """
    Shelly Switch
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, SUBTYPE, did)
        self.responses = {"power": None, "sensor": None}
        self.infos = {"model": "Shelly Door Window"}
        self._present = True
        self.measurement_state = None
        self.measurement_tilt = None
        self.measurement_temperature = None
        self.measurement_lux = None
        self.measurement_battery = None
        self.measurement_vibration = None
        self._illumination = None
        self._last_reasons = {"periodic": dt.datetime(2000, 1, 1)}
        self._error = 0
        self._icon_colour = "#8b0000"

    async def handle_mqtt_error(self, payload):
        self._error = (payload and "yes") or "No"
        if payload == 1:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "alert",
                        "target": self.controller.type + "." + self.name,
                        "value": "error state",
                    },
                }
            )

    async def handle_mqtt_act_reasons(self, payload):
        now = dt.datetime.now()
        for x in payload:
            self._last_reasons[x] = now
        await aio.sleep(0)

    async def handle_mqtt_illumination(self, payload):
        self._illumination = payload
        await aio.sleep(0)

    async def handle_mqtt_state(self, payload):
        await self.handle_mqtt_generic("state", payload)

    async def handle_mqtt_tilt(self, payload):
        await self.handle_mqtt_generic("tilt", payload)

    async def handle_mqtt_temperature(self, payload):
        await self.handle_mqtt_generic("temperature", payload)

    async def handle_mqtt_lux(self, payload):
        await self.handle_mqtt_generic("lux", payload)

    async def handle_mqtt_vibration(self, payload):
        await self.handle_mqtt_generic("vibration", payload)

    async def handle_mqtt_battery(self, payload):
        await self.handle_mqtt_generic("battery", payload)

    async def handle_mqtt_generic(self, prop, payload):
        if getattr(self, f"measurement_{prop}") != payload and payload != -1:
            setattr(self, f"measurement_{prop}", payload)
            if prop == "state":
                msg = {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "measurement",
                        "target": self.controller.type + "." + self.name,
                        "icon status": {
                            "bu-fill": self.icon_colour(),
                            "bu-door-open": {
                                "opacity": 1 if payload == "open" else 0,
                                "fill": self.icon_colour()["fill"],
                            },
                            "bu-door-close": {
                                "opacity": 1 if payload == "close" else 0,
                                "fill": self.icon_colour()["fill"],
                            },
                        },
                        "value": {prop: payload},
                    },
                }
            else:
                msg = {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "measurement",
                        "target": self.controller.type + "." + self.name,
                        "value": {prop: payload},
                    },
                }

            await self.controller.enqueue(msg)
            await self.send_info()
        else:
            if random.randrange(30) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def handle_mqtt_online(self, payload):
        if not payload:
            await self.send_info()
        else:
            if not self.present:
                self.present = True
            await aio.sleep(0)

    async def handle_mqtt_info(self, payload):
        try:
            self.infos["ssid"] = payload["wifi_sta"]["ssid"]
            self.infos["ip"] = payload["wifi_sta"]["ip"]
            self.infos["mac"] = ":".join(
                [
                    payload["mac"][i : i + 2].lower()
                    for i in range(0, len(payload["mac"]), 2)
                ]
            )
            self.infos["new_fw"] = payload["has_update"]
            self.infos["fw_ver"] = payload["update"]["old_version"]
            if payload["cloud"]["enabled"] and payload["cloud"]["connected"]:
                self.infos["cloud"] = "connected"
            else:
                self.infos["cloud"] = "not connected"
            self.infos["last boot"] = (
                dt.datetime.now() - dt.timedelta(seconds=payload["uptime"])
            ).strftime("%d %B %Y at %H:%M")
        except Exception as e:
            _log.debug(f"Problem handling mqtt ingo {e}")

    async def handle_mqtt_announce(self, payload):
        for k, v in payload.items():
            self.infos[k] = v
        self.infos["model"] = "Shelly Door Window " + self.infos["model"].split("-")[-1]
        self.infos["mac"] = ":".join(
            [
                payload["mac"][i : i + 2].lower()
                for i in range(0, len(payload["mac"]), 2)
            ]
        )
        await aio.sleep(0)

    async def send_info(self):
        # Can be used in callback
        try:
            msg = '<div><dl class="dl-horizontal">'
            msg += "<dt>Model:</dt><dd>" + self.infos["model"] + "</dd>"
            loinfo = [
                ("measurement_state", "Door is"),
                ("measurement_temperature", "Temperature"),
                ("measurement_lux", "Lux"),
                ("_illumination", "Illumination"),
                ("measurement_tilt", "Tilt"),
                ("measurement_vibration", "Vibration"),
                ("measurement_battery", "Battery"),
                ("_error", "Error State"),
            ]
            for x, lbl in loinfo:
                if getattr(self, x, None) not in [None, -1]:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(getattr(self, x))
                        + "</dd>"
                    )
            for x, lbl in [
                ("ssid", "WiFi Network"),
                ("mac", "mac address"),
                ("ip", "ip address"),
                ("fw_ver", "firmware"),
                ("new_fw", "firmware upgradable"),
                ("cloud", "cloud"),
                ("last reboot", "last reboot"),
            ]:
                try:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(self.infos[x])
                        + "</dd>"
                    )
                except:
                    pass
            msg += "<dt>Last Seen:</dt><dd>"
            sep = ""
            for k, d in self._last_reasons.items():
                msg += (
                    sep
                    + k.replace("_", " ").title()
                    + ": "
                    + d.strftime("%A, %x at %X")
                )
                sep = "<br />"
            msg += "</dd>"
            if msg:
                msg += "</dl></div>"
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "info",
                            "target": self.controller.type + "." + self.name,
                            "value": msg,
                        },
                    }
                )
            else:
                await aio.sleep(0)
        except Exception as e:
            _log.debug(
                "Ooops could not send info", exc_info=(type(e), e, e.__traceback__)
            )
            await aio.sleep(0)

    def icon_colour(self, force=False):
        """
        Here force can be set to on or off
        """
        return {"fill": self._icon_colour}


SHELLYCLASS = {"shellydw": ShellyS}

bridge_default = {
    "type": "switch",
    "subtype": SUBTYPE,
    "update": False,
}


class ShellyBridge(bl.BuddyMQTT):

    """
    This is the bridge application. It will check for the current list  of shelly
    It will report any new bulb
    """

    def __init__(self, defaults={}, descr="Shelly Switches Bridge"):
        super().__init__(ShellyS, defaults, descr)
        self.mqtt_topics = ["#"]
        self.mqtt_client = None
        self.config_name = "shelly-sensor"
        self.noevent = True
        self.infos = {}
        self.buddy_config["relay"] = []

    async def handle_command_update_config(self, msg):
        # Need to clean before saving. Removing empty relay
        try:
            msg["content"]["value"]["relay"] = [
                x for x in msg["content"]["value"]["relay"] if x["entity"]["bu_cvalue"]
            ]
        except:
            pass
        await super().handle_command_update_config(msg)

    def lp_prepare(self, desc, parser=None, default={}):
        """

        Whenever overloading this,  set your own dftls for those elements
        that need to be set and saved

        Set things in default to your own defaults (e.g. type and subtype

        """
        parser = super().lp_prepare(desc, parser, default)
        # Now we add ipv6prefix
        parser.add_argument(
            "-u",
            "--update",
            action="store_true",
            default=False,
            help="This shall be the bridge module issueing firmware upgrade commands.",
        )
        return parser

    def local_response_save_configuration(self, msg):
        """
        Here we eflect the changes to the discovery mechanisms
        """
        if self.mqtt_client:
            aio.create_task(self.mqtt_client.disconnect())
            self.mqtt_client = None
            self.mqtt_task["mqtt read"].cancel()
        self.mqtt_task["mqtt read"] = aio.create_task(self.mqtt_reader())

    async def handle_command_update_fw(self, msg):
        if self.bridge_config["update"]:
            await self.mqtt_wqueue.put(("command", b"update_fw"))
        else:
            await aio.sleep(0)

    async def global_process_mqtt(self, topic, payload):
        """
        Treat mqtt messages that should not be passed on to devices
        Return True if the message was processed False if it is for devices
        """
        ret = False
        if len(topic.split("/")) == 2 and topic.split("/")[-1] == "announce":
            ret = True
            if reduce(
                lambda x, y: x or y,
                [payload["id"].startswith(z) for z in DEVLIST],
                False,
            ):
                found = False
                _log.debug(f"Announce with {topic} and {payload}")
                for dev in self.devices:
                    if dev.name == payload["id"]:
                        found = True
                        break
                if not found:
                    _log.debug(
                        f"Creating {payload['id']} with {SHELLYCLASS[payload['id'].split('-')[0]]}"
                    )
                    ndev = SHELLYCLASS[payload["id"].split("-")[0]](
                        payload["id"], payload["id"]
                    )
                    ndev.info = payload
                    ndev.controller = self
                    self.pending.append(ndev)
                    await self.enqueue(
                        {
                            "subject": "control" + "." + self.type,
                            "content_type": "request",
                            "content": {
                                "request": "creation",
                                "target": self.type,
                                "value": {
                                    "name": payload["id"],
                                    "nickname": payload["id"],
                                    "subtype": self.subtype,
                                },
                            },
                        }
                    )
                else:
                    await dev.handle_mqtt_announce(payload)
        elif topic.split("/")[-1] in [
            "command",
            "set",
        ]:  # Just a command sent to a device.... ignore
            ret = True
        elif not reduce(lambda x, y: x or y, [z in topic for z in DEVLIST], False):
            ret = True
        else:
            pass
            # _log.debug(f"Global with {topic} and {payload}... with {[z in topic for z in DEVLIST]}")
        await aio.sleep(0)
        return ret

    def topic_to_devices(self, topic):
        """
        Given a topic, returns a 2-uple
            - list of names of devices targeted
            - event
        """
        try:
            lot = topic.split("/")
            return [lot[0]], lot[-1]
        except Exception as e:
            _log.debug(f"t to d from {topic} error:{e}")
            return [], "noop"

    async def mqtt_connection(self):
        """
        Overload to do things once the MQTT ibus is connected
        """
        await self.mqtt_wqueue.put(("command", b"announce"))

    #        await self.mqtt_wqueue.put(("command", b'update'))

    def register(self, dev):
        _log.debug("Registering")
        dev.controller = self
        self.devices.append(dev)
        dev.present = True
        try:
            self.pending.remove(dev)
        except:
            pass


aboutstr = """<p>ShellyBuddy is a bridge talking to WiFi Door/Window sensors made by <a href="https://shelly.cloud">Shelly</a> configured
to communicate over MQTT. The icon used is based on two icons from <a href="http://fontawesome.io">Font Awesome by Dave Gandy - http://fontawesome.io.</a></p>
<p class=\"bu-copyright\">&copy; 2019 Fran&ccedil;ois Wautier</p>
"""

iconstr = """
<svg class="bu-device-icon" width="60" height="60" viewBox="0 0 640 512" xmlns="http://www.w3.org/2000/svg">
    <path class="bu-fill bu-door-open" d="M624 448h-80V113.45C544 86.19 522.47 64 496 64H384v64h96v384h144c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16zM312.24 1.01l-192 49.74C105.99 54.44 96 67.7 96 82.92V448H16c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h336V33.18c0-21.58-19.56-37.41-39.76-32.17zM264 288c-13.25 0-24-14.33-24-32s10.75-32 24-32 24 14.33 24 32-10.75 32-24 32z" opacity="0" />
    <path class="bu-fill bu-door-close" d="M624 448H512V50.8C512 22.78 490.47 0 464 0H175.99c-26.47 0-48 22.78-48 50.8V448H16c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h608c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16zM415.99 288c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32c.01 17.67-14.32 32-32 32z"  opacity="1" />
</svg>
"""


if __name__ == "__main__":
    try:
        bridgectl = ShellyBridge(bridge_default)
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {
                    "about": {"ShellyDWBuddy": aboutstr},
                    "display": {bridgectl.type: {bridgectl.subtype: iconstr}},
                }
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        loop.call_soon(bridgectl.last_rites)
        loop.run_until_complete(aio.sleep(5))
        loop.close()
