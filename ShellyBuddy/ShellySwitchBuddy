#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Shelly lightes
#
# Copyright (c) 2018 FranÃ§ois Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import sys
import logging
import random
import datetime as dt

import buddylib as bl
import asyncio as aio
from functools import reduce

SUBTYPE = "shelly"
CERTFILE = "autobuddy.crt"
BUILDNAME = "ShellyFake"
__version__ = "1.0"

SUBDEVS = {
    "shelly1": 1,
    "shelly1pm": 1,
    "shellyplug": 1,
    "shelly2": 2,
    "shellyswitch25": 2,
    "shelly4pro": 4,
}
MODELS = {
    "shelly1": "Shelly 1",
    "shelly1pm": "Shelly 1PM",
    "shellyplug": "Shelly Plug",
    "shelly2": "Shelly Switch 2",
    "shellyswitch25": "Shelly Switch 2.5",
    "shelly4pro": "Shelly 4Pro",
    "a": "Build",
}
TIMEOUT = 40

_log = logging.getLogger(__name__)


class ShellyS(bl.relayswitch, bl.BuddyDeviceMQTT):
    """
    Shelly Switch
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, SUBTYPE, did)
        self.responses = {"power": None, "switch": None}
        self.infos = {"model": MODELS[name.split("-")[0]]}
        self.measurement_power = None
        self.measurement_energy = None
        self.measurement_temperature = None
        self.measurement_overtemperature = False
        self.measurement_temperature_status = False
        self._overpower = False
        self._last_status = None
        self._icon_colour = "#cc33ff"
        self.hbtask = aio.create_task(self.heartbeat())

    async def heartbeat(self):
        """
        Check last status message
        """
        while True:
            await aio.sleep(TIMEOUT)
            if self._last_status:
                if (
                    dt.datetime.now() - dt.timedelta(seconds=TIMEOUT + 10)
                ) > self._last_status:
                    if self.present:
                        self.present = False
                else:
                    if random.randrange(100) == 17:
                        await self.send_info()

    async def handle_command_switch(self, value, rt):
        # Simulate a toggled switch
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "switch",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {
                        "bu-fill": self.icon_colour(),
                        "bu-not-present": {"opacity": 0},
                    },
                    "value": value,
                },
            }
        )

    async def handle_mqtt_relay(self, payload):
        self._last_status = dt.datetime.now()
        if payload == "overpower":
            if not self._overpower:
                self._overpower = True
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "alert",
                            "target": self.controller.type + "." + self.name,
                            "value": "overpower",
                        },
                    }
                )
            return
        self._overpower = False
        if payload != self.power:
            self.power = payload
            if self.responses["power"]:
                await self.controller.enqueue(self.responses["power"])
                self.responses["power"] = None
            else:
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "power",
                            "target": self.controller.type + "." + self.name,
                            "value": {"power": self.power},
                            "icon status": {
                                "bu-fill": self.icon_colour(),
                                "bu-not-present": {"opacity": 0},
                            },
                        },
                    }
                )
                await self.send_status()
        else:
            await aio.sleep(0)

    async def handle_mqtt_status(self, payload):
        changed = False
        wason = self.power
        self.power = payload["ison"]
        if wason != self.power:
            changed = True

        if self.responses["power"]:
            await self.controller.enqueue(self.responses["power"])
            self.responses["power"] = None
        elif changed:
            await self.send_status()
            await self.send_info()
        else:
            if random.randrange(20) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def handle_mqtt_power(self, payload):
        if self.measurement_power != payload:
            self.measurement_power = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {
                        "bu-fill": self.icon_colour(),
                        "bu-not-present": {"opacity": 0},
                    },
                    "value": {"power": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_energy(self, payload):
        self._last_status = dt.datetime.now()
        if self.measurement_energy != payload:
            self.measurement_energy = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {
                        "bu-fill": self.icon_colour(),
                        "bu-not-present": {"opacity": 0},
                    },
                    "value": {"energy": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_temperature_status(self, payload):
        self.measurement_temperature_status = payload
        await aio.sleep(0)

    async def handle_mqtt_temperature(self, payload):
        self._last_status = dt.datetime.now()
        if self.measurement_temperature != payload:
            self.measurement_temperature = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {
                        "bu-fill": self.icon_colour(),
                        "bu-not-present": {"opacity": 0},
                    },
                    "value": {"temperature": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_overtemperature(self, payload):
        otval = payload == 1
        self._last_status = dt.datetime.now()
        if self.measurement_overtemperature != otval:
            self.measurement_overtemperature = otval
            if self.measurement_overtemperature:
                msg = {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "alert",
                        "target": self.controller.type + "." + self.name,
                        "icon status": {
                            "bu-fill": self.icon_colour(),
                            "bu-not-present": {"opacity": 0},
                        },
                        "value": "overtemperature",
                    },
                }
                await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_online(self, payload):
        self.present = payload
        await aio.sleep(0)

    async def handle_mqtt_info(self, payload):
        try:
            self.infos["ssid"] = payload["wifi_sta"]["ssid"]
            self.infos["ip"] = payload["wifi_sta"]["ip"]
            self.infos["mac"] = ":".join(
                [
                    payload["mac"][i : i + 2].lower()
                    for i in range(0, len(payload["mac"]), 2)
                ]
            )
            self.infos["new_fw"] = payload["has_update"]
            self.infos["fw_ver"] = payload["update"]["old_version"]
            if payload["cloud"]["enabled"] and payload["cloud"]["connected"]:
                self.infos["cloud"] = "connected"
            else:
                self.infos["cloud"] = "not connected"
            self.infos["last boot"] = (
                dt.datetime.now() - dt.timedelta(seconds=payload["uptime"])
            ).strftime("%d %B %Y at %H:%M")
        except Exception as e:
            _log.debug(f"Problem handling mqtt ingo {e}")

    async def handle_mqtt_announce(self, payload):
        for k, v in payload.items():
            self.infos[k] = v
        self.infos["mac"] = ":".join(
            [
                payload["mac"][i : i + 2].lower()
                for i in range(0, len(payload["mac"]), 2)
            ]
        )
        await aio.sleep(0)

    async def local_command_power(self, value, rt, msg=None):
        _log.debug(f"Handling local power with {value},  {rt} and {msg}")
        if msg:
            self.responses["power"] = msg
        devid, idx = self.name.split("_")
        topic = f"{devid}/relay/{idx}/command"
        await self.controller.mqtt_wqueue.put((topic, value["power"]))

    async def send_info(self):
        # Can be used in callback
        try:
            msg = '<div><dl class="dl-horizontal">'
            msg += "<dt>Model:</dt><dd>" + self.name.split("-")[0] + "</dd>"
            loinfo = [
                ("power", "Relay"),
                ("switch", "Switch"),
                ("measurement_power", "Instant Power"),
                ("measurement_energy", "Energy Consumption"),
                ("measurement_temperature", "Internal temperature"),
                ("measurement_temperature_status", "Internal temperature is"),
            ]
            for x, lbl in loinfo:
                if getattr(self, x, None) is not None:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(getattr(self, x))
                        + "</dd>"
                    )
            for x, lbl in [
                ("ssid", "WiFi Network"),
                ("mac", "mac address"),
                ("ip", "ip address"),
                ("fw_ver", "firmware"),
                ("new_fw", "firmware upgradable"),
                ("cloud", "cloud"),
                ("last reboot", "last reboot"),
            ]:
                try:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(self.infos[x])
                        + "</dd>"
                    )
                except:
                    pass
            if msg:
                msg += "</dl></div>"
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "info",
                            "target": self.controller.type + "." + self.name,
                            "value": msg,
                        },
                    }
                )
            else:
                await aio.sleep(0)
        except Exception as e:
            _log.debug(
                "Ooops could not send info", exc_info=(type(e), e, e.__traceback__)
            )
            await aio.sleep(0)

    async def handle_mqtt_input(self, payload):
        curr = self._switch
        self._switch = (payload in [1, "1", "on", "ON", "On", True] and "on") or "off"
        if self._switch != curr:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "switch",
                        "target": self.controller.type + "." + self.name,
                        "icon status": {
                            "bu-fill": self.icon_colour(),
                            "bu-not-present": {"opacity": 0},
                        },
                        "value": {"switch": self._switch},
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_longpush(self, payload):
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "click",
                    "target": self.controller.type + "." + self.name,
                    "value": (payload and "long") or "single",
                },
            }
        )

    async def handle_mqtt_overpower(self, payload):
        self._overpower = payload
        if self._overpower:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "alert",
                        "target": self.controller.type + "." + self.name,
                        "value": "overpower",
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_input_event(self, payload):
        await aio.sleep(0)


bridge_default = {
    "type": "switch",
    "subtype": SUBTYPE,
    "update": False,
}


class ShellyBridge(bl.BuddyMQTT):

    """
    This is the bridge application. It will check for the current list  of shelly
    It will report any new bulb
    """

    def __init__(self, defaults={}, descr="Shelly Switches Bridge"):
        super().__init__(ShellyS, defaults, descr)
        self.mqtt_topics = ["#"]
        self.mqtt_client = None
        self.config_name = "shelly-switch"
        self.noevent = True
        self.infos = {}
        self.buddy_config["relay"] = []

    def configure(self, defaults, descr):
        super().configure(defaults, descr)
        self.config_buddy.append(
            bl.xml.xml_asis(
                "relay",
                """
        <controlgroup type="listmaker"  name="relay" label="Relay Use">
            <control name="label" label="Label" type="text" length="16" />
            <control name="entity" expand="device::switch::shelly" label="Shelly Switch" type="text" length="16" />
            <controlgroup type="choice" name="relay" label="Use Relay?">
                <item value="yes" label="Yes use the relay." />
                <item value="no" label="Do not use the relay." >
                    <control type="switch" name="state" label="Relay State" rteffect="1">
                        <value label="On">on</value>
                        <value label="Off">off</value>
                    </control>
                </item>
            </controlgroup>
        </controlgroup>
        """,
            )
        )

    async def handle_command_update_config(self, msg):
        # Need to clean before saving. Removing empty relay
        try:
            msg["content"]["value"]["relay"] = [
                x for x in msg["content"]["value"]["relay"] if x["entity"]["bu_cvalue"]
            ]
        except:
            pass
        await super().handle_command_update_config(msg)

    def lp_prepare(self, desc, parser=None, default={}):
        """

        Whenever overloading this,  set your own dftls for those elements
        that need to be set and saved

        Set things in default to your own defaults (e.g. type and subtype

        """
        parser = super().lp_prepare(desc, parser, default)
        # Now we add ipv6prefix
        parser.add_argument(
            "-u",
            "--update",
            action="store_true",
            default=False,
            help="This shall be the bridge module issueing firmware upgrade commands.",
        )
        return parser

    def local_response_save_configuration(self, msg):
        """
        Here we eflect the changes to the discovery mechanisms
        """
        # Update relay thing
        loswitch = [
            x["entity"].split(".")[1]
            for x in self.buddy_config["relay"]
            if x["relay"]["selection"] == "no"
        ]
        _log.debug(f"Relay update for {loswitch}")
        for dev in self.devices:
            if dev.name in loswitch:
                dev._icon_follow_relay = False
            else:
                _log.debug(f"{dev.name} is software switch")
                dev._icon_follow_relay = True
            aio.create_task(dev.send_status())
        if self.mqtt_client:
            aio.create_task(self.mqtt_client.disconnect())
            self.mqtt_client = None
            self.mqtt_task["mqtt read"].cancel()
        self.mqtt_task["mqtt read"] = aio.create_task(self.mqtt_reader())

    async def handle_command_update_fw(self, msg):
        if self.bridge_config["update"]:
            await self.mqtt_wqueue.put(("command", b"update_fw"))
        else:
            await aio.sleep(0)

    def build(self, devices):
        self.devices += ShellyS.from_list(devices)
        _log.debug(f"Processed config is {self.buddy_config}")
        loswitch = [
            x["entity"].split(".")[1]
            for x in self.buddy_config["relay"]
            if x["relay"]["selection"] == "no"
        ]
        if self.bridge_config["update"]:
            self.command_buddy["update_fw"] = {
                "module": self.bridge_config["type"],
                "value": self.bridge_config["subtype"],
                "label": "Update Shellies Firmware",
            }
        for dev in self.devices:
            dev.controller = self
            if dev.name in loswitch:
                dev._icon_follow_relay = False
            else:
                dev._icon_follow_relay = True
            dev.present = False

    async def global_process_mqtt(self, topic, payload):
        """
        Treat mqtt messages that should not be passed on to devices
        Return True if the message was processed False if it is for devices
        """
        ret = False
        if len(topic.split("/")) == 2 and topic.split("/")[-1] == "announce":
            ret = True
            if reduce(
                lambda x, y: x or y,
                [payload["id"].startswith(z) for z in SUBDEVS.keys()],
                False,
            ):
                found = False
                _log.debug(f"Announce with {topic} and {payload}")
                for dev in self.devices:
                    if dev.name == payload["id"] + "_0":
                        found = True
                        break
                if not found:
                    # TODO Remove this
                    # _log.debug(f"Would create {payload['id']}")
                    # return ret
                    for idx in range(SUBDEVS[payload['id'].split("-")[0]]):
                        _log.debug(f"Creating {payload['id']}_{idx}")
                        ndev = ShellyS(
                            payload["id"] + f"_{idx}", payload["id"] + f"_{idx}"
                        )
                        ndev.info = payload
                        ndev.infos["mac"] = ":".join(
                            [
                                payload["mac"][i : i + 2].lower()
                                for i in range(0, len(payload["mac"]), 2)
                            ]
                        )
                        ndev.controller = self
                        self.pending.append(ndev)
                        await self.enqueue(
                            {
                                "subject": "control" + "." + self.type,
                                "content_type": "request",
                                "content": {
                                    "request": "creation",
                                    "target": self.type,
                                    "value": {
                                        "name": payload["id"]+ f"_{idx}",
                                        "nickname": payload["id"]+ f"_{idx}",
                                        "subtype": self.subtype,
                                    },
                                },
                            }
                        )
        elif topic.split("/")[-1] in [
            "command",
            "temperature_f",
        ]:  # Just a command sent to a device.... ignore
            ret = True
        elif not reduce(
            lambda x, y: x or y, [z in topic for z in SUBDEVS.keys()], False
        ):
            ret = True
        else:
            pass
            # _log.debug(f"Global with {topic} and {payload}... with {[z in topic for z in DEVLIST]}")
        await aio.sleep(0)
        return ret

    def topic_to_devices(self, topic):
        """
        Given a topic, returns a 2-uple
            - list of names of devices targeted
            - event
        """
        try:
            lot = topic.split("/")
            model = lot[0].split("-")[0]
            if len(lot) == 2:
                return [f"{lot[0]}_{x}" for x in range(SUBDEVS[model])], lot[1]

            if len(lot) == 3:
                return [lot[0] + "_" + lot[2]], lot[1]

            if len(lot) == 4:
                return [lot[0] + "_" + lot[2]], lot[3]
            raise Exception("Unknown topic")
        except Exception as e:
            _log.debug(f"t to d from {topic} error:{e}")
            return [], "noop"

    async def mqtt_connection(self):
        """
        Overload to do things once the MQTT ibus is connected
        """
        await self.mqtt_wqueue.put(("command", b"announce"))

    #        await self.mqtt_wqueue.put(("command", b'update'))

    def last_rites(self):
        try:
            # Stop the heartbeat
            for dev in self.devices:
                dev.hbtask.cancel()
            super().last_rites()
        except:
            pass


aboutstr = """<p>ShellySwitchBuddy is a bridge talking to WiFi switches made by <a href="https://shelly.cloud">Shelly</a> configured
to communicate over MQTT. The icon used is based on one made by Freepik from www.flaticon.com </p>
<p class=\"bu-copyright\">&copy; 2019 Fran&ccedil;ois Wautier</p>
"""


if __name__ == "__main__":
    try:
        bridgectl = ShellyBridge(bridge_default)
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {
                    "about": {"ShellySwitchBuddy": aboutstr},
                    "display": {"switch": {SUBTYPE: ShellyS.icon}},
                }
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        bridgectl.last_rites()
        loop.run_until_complete(aio.sleep(3))
        loop.close()
