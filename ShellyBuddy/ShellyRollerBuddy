#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Shelly lightes
#
# Copyright (c) 2018 FranÃ§ois Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import sys
import logging
import random
import datetime as dt

import buddylib as bl
import asyncio as aio
from functools import reduce

SUBTYPE = "shelly"
CERTFILE = "autobuddy.crt"
BUILDNAME = "ShellyFake"
__version__ = "1.0"

SUBDEVS = {
    "shellyroller": 1,
}
MODELS = {"shellyroller": "Shelly Switch 2.5", "a": "Build"}
TIMEOUT = 40

_log = logging.getLogger(__name__)


class ShellyR(bl.drape, bl.BuddyDeviceMQTT):
    """
    Shelly Switch
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, SUBTYPE, did)
        self.responses = {"switch0": None, "switch1": None, "command": None}
        self.infos = {"model": MODELS[name.split("-")[0]]}
        self.measurement_power = None
        self.measurement_energy = None
        self.measurement_temperature = None
        self.measurement_overtemperature = False
        self.measurement_temperature_status = False
        self._switch0 = "off"
        self._switch1 = "off"
        self._last_stop = "Undef"
        self._overpower = False
        self._last_status = None
        self._icon_colour = None
        self._stop_cd = 3
        self._stop_cd_start = 0
        self.hbtask = aio.create_task(self.heartbeat())

    async def heartbeat(self):
        """
        Check last status message
        """
        while True:
            await aio.sleep(TIMEOUT)
            if self._last_status:
                if (
                    dt.datetime.now() - dt.timedelta(seconds=TIMEOUT + 10)
                ) > self._last_status:
                    if self.present:
                        self.present = False
                else:
                    if random.randrange(100) == 17:
                        await self.send_info()

    async def handle_command_switch0(self, value, rt):
        # Simulate a toggled switch
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "switch0",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {"bu-not-present": {"opacity": 0}},
                    "value": value["switch"],
                },
            }
        )

    # A couple of useless handling
    async def handle_mqtt_roller(self, payload):
        if payload in ["open", "close"] and self.responses["command"]:
            msg = self.responses["command"]
            self.responses["command"] = None
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_relay(self, payload):
        await aio.sleep(0)

    async def handle_mqtt_pos(self, payload):
        payload = round(100 - payload)
        if self._stop_cd:
            self._stop_cd -= 1
        if payload != self._percent_close:
            self._percent_close = payload
            if self.responses["command"]:
                msg = self.responses["command"]
                self.responses["command"] = None
                await self.controller.enqueue(msg)
            else:
                await self.send_status()
        elif self._stop_cd == 1:
            self._stop_cd = 0

            iconsts = {
                "animation": self.gen_anim(self._stop_cd_start, self._percent_close)
            }
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "noop",
                    "target": self.controller.type + "." + self.name,
                    "icon status": iconsts,
                    "value": "",
                },
            }
            self._stop_cd_start = self._percent_close
            await aio.sleep(3)
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_stop_reason(self, payload):
        self._last_stop = payload

    async def handle_mqtt_status(self, payload):
        if self.responses["command"]:
            msg = self.responses["command"]
            self.responses["command"] = None
            await self.controller.enqueue(msg)
        else:
            if random.randrange(20) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def handle_mqtt_power(self, payload):
        if self.measurement_power != payload:
            self.measurement_power = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {"bu-not-present": {"opacity": 0}},
                    "value": {"power": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            if random.randrange(20) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def handle_mqtt_energy(self, payload):
        self._last_status = dt.datetime.now()
        if self.measurement_energy != payload:
            self.measurement_energy = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {"bu-not-present": {"opacity": 0}},
                    "value": {"energy": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_temperature_status(self, payload):
        self.measurement_temperature_status = payload
        await aio.sleep(0)

    async def handle_mqtt_temperature(self, payload):
        self._last_status = dt.datetime.now()
        if self.measurement_temperature != payload:
            self.measurement_temperature = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {"bu-not-present": {"opacity": 0}},
                    "value": {"temperature": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_overtemperature(self, payload):
        otval = payload == 1
        self._last_status = dt.datetime.now()
        if self.measurement_overtemperature != otval:
            self.measurement_overtemperature = otval
            if self.measurement_overtemperature:
                msg = {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "alert",
                        "target": self.controller.type + "." + self.name,
                        "icon status": {
                            "bu-fill": self.icon_colour(),
                            "bu-not-present": {"opacity": 0},
                        },
                        "value": "overtemperature",
                    },
                }
                await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_online(self, payload):
        self.present = payload
        await aio.sleep(0)

    async def handle_mqtt_info(self, payload):
        try:
            self.infos["ssid"] = payload["wifi_sta"]["ssid"]
            self.infos["ip"] = payload["wifi_sta"]["ip"]
            self.infos["mac"] = ":".join(
                [
                    payload["mac"][i : i + 2].lower()
                    for i in range(0, len(payload["mac"]), 2)
                ]
            )
            self.infos["new_fw"] = payload["has_update"]
            self.infos["fw_ver"] = payload["update"]["old_version"]
            if payload["cloud"]["enabled"] and payload["cloud"]["connected"]:
                self.infos["cloud"] = "connected"
            else:
                self.infos["cloud"] = "not connected"
            self.infos["last boot"] = (
                dt.datetime.now() - dt.timedelta(seconds=payload["uptime"])
            ).strftime("%d %B %Y at %H:%M")
        except Exception as e:
            _log.debug(f"Problem handling mqtt ingo {e}")

    async def handle_mqtt_announce(self, payload):
        for k, v in payload.items():
            self.infos[k] = v
        self.infos["mac"] = ":".join(
            [
                payload["mac"][i : i + 2].lower()
                for i in range(0, len(payload["mac"]), 2)
            ]
        )
        await aio.sleep(0)

    async def local_command_open(self, value, rt, msg=None):
        _log.debug(f"Handling local open with {value},  {rt} and {msg}")
        self._stop_cd_start = 0  # Animation will end there
        if msg:
            self.responses["command"] = msg
        topic = f"{self.name}/roller/0/command"
        await self.controller.mqtt_wqueue.put((topic, "open"))

    async def local_command_stop(self, value, rt, msg=None):
        _log.debug(f"Handling local stop with {value},  {rt} and {msg}")
        self._stop_cd = 3
        self.responses["command"] = None
        topic = f"{self.name}/roller/0/command"
        await self.controller.mqtt_wqueue.put((topic, "stop"))

    async def local_command_close(self, value, rt, msg=None):
        _log.debug(f"Handling local close with {value},  {rt} and {msg}")
        self._stop_cd_start = 100  # Animation will end there
        if msg:
            self.responses["command"] = msg
        topic = f"{self.name}/roller/0/command"
        await self.controller.mqtt_wqueue.put((topic, "close"))

    async def send_info(self):
        # Can be used in callback
        try:
            msg = '<div><dl class="dl-horizontal">'
            msg += "<dt>Model:</dt><dd>" + self.name.split("-")[0] + "</dd>"
            msg += f"<dt>Position:</dt><dd>{self._percent_close}% close</dd>"
            loinfo = [
                ("_switch0", "Switch 0"),
                ("_switch1", "Switch 1"),
                ("_lasat_stop", "Last Stop Status"),
                ("measurement_power", "Instant Power"),
                ("measurement_energy", "Energy Consumption"),
                ("measurement_temperature", "Internal temperature"),
                ("measurement_temperature_status", "Internal temperature is"),
            ]
            for x, lbl in loinfo:
                if getattr(self, x, None) is not None:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(getattr(self, x))
                        + "</dd>"
                    )
            for x, lbl in [
                ("ssid", "WiFi Network"),
                ("mac", "mac address"),
                ("ip", "ip address"),
                ("fw_ver", "firmware"),
                ("new_fw", "firmware upgradable"),
                ("cloud", "cloud"),
                ("last reboot", "last reboot"),
            ]:
                try:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(self.infos[x])
                        + "</dd>"
                    )
                except:
                    pass
            if msg:
                msg += "</dl></div>"
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "info",
                            "target": self.controller.type + "." + self.name,
                            "value": msg,
                        },
                    }
                )
            else:
                await aio.sleep(0)
        except Exception as e:
            _log.debug(
                "Ooops could not send info", exc_info=(type(e), e, e.__traceback__)
            )
            await aio.sleep(0)

    async def handle_mqtt_input0(self, payload):
        curr = self._switch0
        self._switch0 = (payload in [1, "1", "on", "ON", "On", True] and "on") or "off"
        if self._switch0 != curr:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "switch0",
                        "target": self.controller.type + "." + self.name,
                        "icon status": {"bu-not-present": {"opacity": 0}},
                        "value": self._switch0,
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_input1(self, payload):
        curr = self._switch1
        self._switch1 = (payload in [1, "1", "on", "ON", "On", True] and "on") or "off"
        if self._switch1 != curr:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "switch1",
                        "target": self.controller.type + "." + self.name,
                        "icon status": {"bu-not-present": {"opacity": 0}},
                        "value": self._switch1,
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_longpush(self, payload):
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "click",
                    "target": self.controller.type + "." + self.name,
                    "value": (payload and "long") or "single",
                },
            }
        )

    async def handle_mqtt_overpower(self, payload):
        self._overpower = payload
        if self._overpower:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "alert",
                        "target": self.controller.type + "." + self.name,
                        "value": "overpower",
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_input_event(self, payload):
        await aio.sleep(0)


bridge_default = {
    "type": "drape",
    "subtype": SUBTYPE,
    "update": False,
}


class ShellyBridge(bl.BuddyMQTT):

    """
    This is the bridge application. It will check for the current list  of shelly
    It will report any new bulb
    """

    def __init__(self, defaults={}, descr="Shelly Switches Bridge"):
        super().__init__(ShellyR, defaults, descr)
        self.mqtt_topics = ["#"]
        self.mqtt_client = None
        self.config_name = "shelly-drape"
        self.noevent = True
        self.infos = {}
        self.buddy_config["relay"] = []

    def lp_prepare(self, desc, parser=None, default={}):
        """

        Whenever overloading this,  set your own dftls for those elements
        that need to be set and saved

        Set things in default to your own defaults (e.g. type and subtype

        """
        parser = super().lp_prepare(desc, parser, default)
        # Now we add ipv6prefix
        parser.add_argument(
            "-u",
            "--update",
            action="store_true",
            default=False,
            help="This shall be the bridge module issueing firmware upgrade commands.",
        )
        return parser

    def local_response_save_configuration(self, msg):
        """
        Here we eflect the changes to the discovery mechanisms
        """
        if self.mqtt_client:
            aio.create_task(self.mqtt_client.disconnect())
            self.mqtt_client = None
            self.mqtt_task["mqtt read"].cancel()
        self.mqtt_task["mqtt read"] = aio.create_task(self.mqtt_reader())

    async def handle_command_update_fw(self, msg):
        if self.bridge_config["update"]:
            await self.mqtt_wqueue.put(("command", b"update_fw"))
        else:
            await aio.sleep(0)

    def build(self, devices):
        self.devices += ShellyR.from_list(devices)
        _log.debug(f"Processed config is {self.buddy_config}")
        if self.bridge_config["update"]:
            self.command_buddy["update_fw"] = {
                "module": self.bridge_config["type"],
                "value": self.bridge_config["subtype"],
                "label": "Update Shellies Firmware",
            }
        for dev in self.devices:
            dev.controller = self
            dev.present = False

    async def global_process_mqtt(self, topic, payload):
        """
        Treat mqtt messages that should not be passed on to devices
        Return True if the message was processed False if it is for devices
        """
        ret = False
        if len(topic.split("/")) == 2 and topic.split("/")[-1] == "announce":
            ret = True
            if reduce(
                lambda x, y: x or y,
                [payload["id"].startswith(z) for z in SUBDEVS.keys()],
                False,
            ):
                found = False
                _log.debug(f"Announce with {topic} and {payload}")
                for dev in self.devices:
                    if dev.name == payload["id"]:
                        found = True
                        break
                if not found:
                    # TODO Remove this
                    _log.debug(f"Would create {payload['id']}")
                    return ret
                    _log.debug(f"Creating {payload['id']}")
                    ndev = ShellyR(payload["id"], payload["id"])
                    ndev.info = payload
                    ndev.infos["mac"] = ":".join(
                        [
                            payload["mac"][i : i + 2].lower()
                            for i in range(0, len(payload["mac"]), 2)
                        ]
                    )
                    self.pending.append(ndev)
                    await self.enqueue(
                        {
                            "subject": "control" + "." + self.type,
                            "content_type": "request",
                            "content": {
                                "request": "creation",
                                "target": self.type,
                                "value": {
                                    "name": payload["id"],
                                    "nickname": payload["id"],
                                    "subtype": self.subtype,
                                },
                            },
                        }
                    )
        elif topic.split("/")[-1] in [
            "command",
            "temperature_f",
        ]:  # Just a command sent to a device.... ignore
            ret = True
        elif not reduce(
            lambda x, y: x or y, [z in topic for z in SUBDEVS.keys()], False
        ):
            ret = True
        else:
            pass
            # _log.debug(f"Global with {topic} and {payload}... with {[z in topic for z in DEVLIST]}")
        await aio.sleep(0)
        return ret

    def topic_to_devices(self, topic):
        """
        Given a topic, returns a 2-uple
            - list of names of devices targeted
            - event
        """
        try:
            lot = topic.split("/")
            if len(lot) == 2:
                return [lot[0]], lot[1]

            if len(lot) == 3:
                if lot[1] == "input":
                    cmd = lot[1] + lot[2]
                else:
                    cmd = lot[1]
                return [lot[0]], cmd

            if len(lot) == 4:
                return [lot[0]], lot[3]
            raise Exception("Unknown topic")
        except Exception as e:
            _log.debug(f"t to d from {topic} error:{e}")
            return [], "noop"

    async def mqtt_connection(self):
        """
        Overload to do things once the MQTT ibus is connected
        """
        await self.mqtt_wqueue.put(("command", b"announce"))

    #        await self.mqtt_wqueue.put(("command", b'update'))

    def last_rites(self):
        try:
            # Stop the heartbeat
            for dev in self.devices:
                dev.hbtask.cancel()
            super().last_rites()
        except:
            pass


aboutstr = """<p>ShellyRollerBuddy is a bridge talking to WiFi rollers made by <a href="https://shelly.cloud">Shelly</a> configured
to communicate over MQTT.</p><p>To work, the MQTT prefix needs to be changed to \"shellyroller\".</p>
<p class=\"bu-copyright\">&copy; 2019 Fran&ccedil;ois Wautier</p>
"""

if __name__ == "__main__":
    try:
        bridgectl = ShellyBridge(bridge_default)
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {
                    "about": {"ShellyRollerBuddy": aboutstr},
                    "display": {bridgectl.type: {bridgectl.subtype: ShellyR.icon}},
                }
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        bridgectl.last_rites()
        loop.run_until_complete(aio.sleep(3))
        loop.close()
