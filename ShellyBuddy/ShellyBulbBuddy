#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Shelly lightes
#
# Copyright (c) 2018 FranÃ§ois Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import sys
import logging
import colorsys
import random
import datetime as dt

import buddylib as bl
import asyncio as aio
from functools import reduce

SUBTYPE = "shelly"
CERTFILE = "autobuddy.crt"
BUILDNAME = "ShellyFake"
__version__ = "1.0"


DEVLIST = ["shellybulb", "ShellyVintage", "shellyrgbw2", "shellycolorbulb"]
MQTTXTRA = {
    "shellybulb": "/color/0",
    "shellycolorbulb": "/color/0",
    "ShellyVintage": "/light/0",
    "shellyrgbw2": "/color/0",
}
TIMEOUT = 40

bridge_default = {
    "type": "light",
    "subtype": SUBTYPE,
    "update": False,
}
_log = logging.getLogger(__name__)


class ShellyV(bl.light, bl.BuddyDeviceMQTT):
    """
    Shelly Vintage
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, SUBTYPE, did)
        self.busy = aio.Lock()
        self.interrupt_busy = False
        self.rt_duration = "no"
        self._brightness_range = [0, 100, 1]
        self._colour_range = False
        self._temperature = 2700
        self._temperature_range = [2700, 2700, 0]
        self.responses = {"power": None, "white": None}
        self.mqttcmd = "/light/0/"
        self.infos = {"model": "Shelly Vintage"}
        self.measurement_power = None
        self.measurement_energy = None
        self._last_status = None
        self.hbtask = aio.create_task(self.heartbeat())

    async def heartbeat(self):
        """
        Check last status message
        """
        try:
            while True:
                await aio.sleep(TIMEOUT)
                if self._last_status:
                    if (
                        dt.datetime.now() - dt.timedelta(seconds=TIMEOUT + 10)
                    ) > self._last_status:
                        if self.present:
                            self.present = False
        except aio.CancelledError:
            return
        except Exception as e:
            _log.warning(f"Shelly's bulb heartbeat dies unexpectedly: {e}")

    async def _timed(self, target):
        """Perform the changes gradually

        Target id a dictionary with keys:
            mode
            duration
        and, for mode "white"
            temperature
            brightness
        and for mode "color"
            red
            green
            blue
            gain
        """
        async with self.busy:
            steps = int(round(target["duration"] * 5))
            if target["mode"] == "white":
                if "temperature" in target:
                    tdelta = int(
                        round((target["temperature"] - self._temperature) / steps)
                    )
                    tvals = [
                        target["temperature"] - (i - 1) * tdelta
                        for i in range(steps, 0, -1)
                    ]
                bdelta = int(round((target["brightness"] - self._brightness) / steps))
                bvals = [
                    target["brightness"] - (i - 1) * bdelta for i in range(steps, 0, -1)
                ]
                if "temperature" in target:
                    allvals = [
                        {"mode": "white", "brightness": x, "temp": y}
                        for x, y in zip(bvals, tvals)
                    ]
                else:
                    allvals = [{"mode": "white", "brightness": x} for x in bvals]
            else:
                rdelta = int(round((target["red"] - self.red) / steps))
                gdelta = int(round((target["green"] - self.green) / steps))
                bdelta = int(round((target["blue"] - self.blue) / steps))
                zdelta = int(round((target["gain"] - self.gain) / steps))
                rvals = [target["red"] - (i - 1) * rdelta for i in range(steps, 0, -1)]
                gvals = [
                    target["green"] - (i - 1) * gdelta for i in range(steps, 0, -1)
                ]
                bvals = [target["blue"] - (i - 1) * bdelta for i in range(steps, 0, -1)]
                zvals = [target["gain"] - (i - 1) * zdelta for i in range(steps, 0, -1)]
                allvals = [
                    {
                        "mode": "color",
                        "white": 0,
                        "red": x,
                        "green": y,
                        "blue": z,
                        "gain": t,
                    }
                    for x, y, z, t in zip(rvals, gvals, bvals, zvals)
                ]

            topic = self.name + self.mqttcmd + "set"
            for aval in allvals:
                if self.interrupt_busy:
                    self.interrupt_busy = False
                    return

                await self.controller.mqtt_wqueue.put((topic, aval))
                await aio.sleep(0.2)

    async def handle_mqtt_onoff(self, payload):
        if payload != self.power:
            self.power = payload
            if self.responses["power"]:
                await self.controller.enqueue(self.responses["power"])
                self.responses["power"] = None
            else:
                await self.send_status_delayed()
        else:
            await aio.sleep(0)

    async def handle_mqtt_status(self, payload):
        changed = False
        wason = self.power
        self._last_status = dt.datetime.now()
        self.power = payload["ison"]
        if wason != self.power:
            changed = True
        cur_colour = self.colour
        self.colour = {"brightness": payload["brightness"]}
        if self.colour != cur_colour:
            changed = True
        if self.responses["white"]:
            await self.controller.enqueue(self.responses["white"])
            self.responses["white"] = None
        elif changed:
            await self.send_status()
            await self.send_info()
        else:
            if random.randrange(20) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def handle_mqtt_power(self, payload):
        if self.measurement_power != payload:
            self.measurement_power = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {
                        "bu-fill": self.icon_colour(),
                        "bu-not-present": {"opacity": 0},
                    },
                    "value": {"power": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_energy(self, payload):
        if self.measurement_energy != payload:
            self.measurement_energy = payload
            msg = {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "measurement",
                    "target": self.controller.type + "." + self.name,
                    "icon status": {
                        "bu-fill": self.icon_colour(),
                        "bu-not-present": {"opacity": 0},
                    },
                    "value": {"energy": payload},
                },
            }
            await self.controller.enqueue(msg)
        else:
            await aio.sleep(0)

    async def handle_mqtt_online(self, payload):
        self.present = payload
        await aio.sleep(0)

    async def handle_mqtt_info(self, payload):
        try:
            self.infos["ssid"] = payload["wifi_sta"]["ssid"]
            self.infos["ip"] = payload["wifi_sta"]["ip"]
            self.infos["mac"] = ":".join(
                [
                    payload["mac"][i : i + 2].lower()
                    for i in range(0, len(payload["mac"]), 2)
                ]
            )
            self.infos["new_fw"] = payload["has_update"]
            self.infos["fw_ver"] = payload["update"]["old_version"]
            if payload["cloud"]["enabled"] and payload["cloud"]["connected"]:
                self.infos["cloud"] = "connected"
            else:
                self.infos["cloud"] = "not connected"
            self.infos["last boot"] = (
                dt.datetime.now() - dt.timedelta(seconds=payload["uptime"])
            ).strftime("%d %B %Y at %H:%M")
        except Exception as e:
            _log.debug(f"Problem handling mqtt ingo {e}")

    async def handle_mqtt_announce(self, payload):
        for k, v in payload.items():
            self.infos[k] = v
        self.infos["mac"] = ":".join(
            [
                payload["mac"][i : i + 2].lower()
                for i in range(0, len(payload["mac"]), 2)
            ]
        )
        await aio.sleep(0)

    async def local_command_power(self, value, rt, msg=None):
        _log.debug(f"Handling local power with {value},  {rt} and {msg}")
        if msg:
            self.responses["power"] = msg
        if "duration" in value and value["duration"]:
            duration = int(value["duration"])
            # TODO use _timed ...  but how to recover brighness?
            # await aio.sleep(0)
        topic = self.name + self.mqttcmd + "command"
        await self.controller.mqtt_wqueue.put((topic, value["power"]))

    async def local_command_white(self, value, rt, msg=None):
        if msg:
            self.responses["white"] = msg

        if "duration" in value and value["duration"]:
            if self.busy.locked():
                self.interrupt_busy = True
            if "temperature" in value:
                aio.create_task(
                    self._timed(
                        {
                            "mode": "white",
                            "duration": value["duration"],
                            "brightness": value["brightness"],
                            "temperature": value["temperature"],
                        }
                    )
                )
            else:
                aio.create_task(
                    self._timed(
                        {
                            "mode": "white",
                            "duration": value["duration"],
                            "brightness": value["brightness"],
                        }
                    )
                )
        else:
            topic = self.name + self.mqttcmd + "set"
            if "temperature" in value:
                payload = {
                    "mode": "white",
                    "temp": value["temperature"],
                    "brightness": value["brightness"],
                }
            else:
                payload = {
                    "brightness": value["brightness"],
                }
            await self.controller.mqtt_wqueue.put((topic, payload))

    async def send_info(self):
        # Can be used in callback
        try:
            msg = '<div><dl class="dl-horizontal">'
            msg += "<dt>Model:</dt><dd>" + self.name.split("-")[0] + "</dd>"
            loinfo = [
                ("power", "Light"),
                ("measurement_power", "Instant Power"),
                ("measurement_energy", "Energy Consumption"),
                ("_switch", "Switch Position"),
                ("_overpower", "Overpower condition"),
            ]
            for x, lbl in loinfo:
                if getattr(self, x, None) is not None:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(getattr(self, x))
                        + "</dd>"
                    )
            for x, lbl in [
                ("ssid", "WiFi Network"),
                ("mac", "mac address"),
                ("ip", "ip address"),
                ("fw_ver", "firmware"),
                ("new_fw", "firmware upgradable"),
                ("cloud", "cloud"),
                ("last reboot", "last reboot"),
            ]:
                try:
                    msg += (
                        "<dt>"
                        + lbl.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(self.infos[x])
                        + "</dd>"
                    )
                except:
                    pass
            if msg:
                msg += "</dl></div>"
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "info",
                            "target": self.controller.type + "." + self.name,
                            "value": msg,
                        },
                    }
                )
            else:
                await aio.sleep(0)
        except Exception as e:
            _log.debug(f"Ooops could not send info {e}")
            await aio.sleep(0)


class ShellyB(ShellyV):
    """
    Shelly Bulb
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, did=did)
        self.mqttcmd = "/color/0/"
        self._colour_range = True
        self._temperature_range = [3000, 6500, 100]
        self.responses["colour"] = None
        self.infos["model"] = "Shelly Bulb"

    async def handle_mqtt_status(self, payload):
        changed = False
        wason = self.power
        self.power = payload["ison"]
        if wason != self.power:
            changed = True
        cur_colour = self.colour
        msg = None
        if payload["mode"] == "white":
            self.colour = {
                "brightness": payload["brightness"],
                "temperature": payload["temp"],
            }
            if self.responses["white"]:
                msg = self.responses["white"]
                self.responses["white"] = None
        elif payload["mode"] == "color":
            self.colour = {
                x: y for x, y in payload.items() if x in ["red", "green", "blue"]
            }
            if self.responses["colour"]:
                msg = self.responses["colour"]
                self.responses["colour"] = None

        if self.colour != cur_colour:
            changed = True
        if msg:
            await self.controller.enqueue(msg)
        elif changed:
            await self.send_status()
            await self.send_info()
        else:
            if random.randrange(20) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def local_command_colour(self, value, rt, msg=None):
        if msg:
            self.responses["colour"] = msg

        colour = [
            x
            for x in map(
                lambda x: int(round(x * 255.0)),
                colorsys.hsv_to_rgb(
                    value["hue"] / 360.0,
                    value["saturation"] / 100.0,
                    1.0,  # value["value"] / 100.0,
                ),
            )
        ]
        mqttmsg = {"mode": "color", "white": 0}
        mqttmsg["red"] = colour[0]
        mqttmsg["green"] = colour[1]
        mqttmsg["blue"] = colour[2]
        mqttmsg["gain"] = value["value"]
        if "duration" in value and value["duration"]:
            if self.busy.locked():
                self.interrupt_busy = True
            mqttmsg["duration"] = value["duration"]
            aio.create_task(self._timed(mqttmsg))
            await aio.sleep(0)
        else:
            topic = self.name + self.mqttcmd + "set"
            await self.controller.mqtt_wqueue.put((topic, mqttmsg))


class ShellyCB(ShellyB):
    """
    Shelly Bulb
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, did=did)
        self.infos["model"] = "Shelly Colour Duo"


class ShellyRGB(ShellyV):
    """
    Shelly Bulb
    """

    def __init__(self, name, nickname, did=None):
        super().__init__(name, nickname, did=did)
        self.mqttcmd = "/color/0/"
        self._colour_range = True
        self._temperature = 4500
        self._temperature_range = [4500, 4500, 0]
        self._switch = "unknown"
        self._overpower = False
        self.responses["colour"] = None
        self.infos["model"] = "Shelly RGBW2"

    async def local_command_white(self, value, rt, msg=None):
        if msg:
            self.responses["white"] = msg

        if "duration" in value and value["duration"]:
            if self.busy.locked():
                self.interrupt_busy = True

            aio.create_task(
                self._timed(
                    {
                        "mode": "white",
                        "duration": value["duration"],
                        "white": value["brightness"],
                    }
                )
            )
        else:
            topic = self.name + self.mqttcmd + "set"
            payload = {
                "mode": "color",
                "gain": value["brightness"],
                "red": 0,
                "green": 0,
                "blue": 0,
                "white": 100,
            }
            await self.controller.mqtt_wqueue.put((topic, payload))

    async def local_command_colour(self, value, rt, msg=None):
        if msg:
            self.responses["colour"] = msg

        colour = [
            x
            for x in map(
                lambda x: int(round(x * 255.0)),
                colorsys.hsv_to_rgb(
                    value["hue"] / 360.0,
                    value["saturation"] / 100.0,
                    1.0,  # value["value"] / 100.0,
                ),
            )
        ]
        mqttmsg = {"mode": "color", "white": 0}
        mqttmsg["red"] = colour[0]
        mqttmsg["green"] = colour[1]
        mqttmsg["blue"] = colour[2]
        mqttmsg["gain"] = value["value"]
        mqttmsg["white"] = 0
        if "duration" in value and value["duration"]:
            if self.busy.locked():
                self.interrupt_busy = True
            mqttmsg["duration"] = value["duration"]
            aio.create_task(self._timed(mqttmsg))
            await aio.sleep(0)
        else:
            topic = self.name + self.mqttcmd + "set"
            await self.controller.mqtt_wqueue.put((topic, mqttmsg))

    async def handle_mqtt_input(self, payload):
        curr = self._switch
        self._switch = (payload in [1, "1", "on", "ON", "On", True] and "on") or "off"
        if self._switch != curr:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "switch",
                        "target": self.controller.type + "." + self.name,
                        "value": self._switch,
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_status(self, payload):
        changed = False
        wason = self.power
        self.power = payload["ison"]
        if wason != self.power:
            changed = True
        cur_colour = self.colour
        msg = None
        if payload["white"] == 100:
            self.colour = {"brightness": payload["gain"]}
            if self.responses["white"]:
                msg = self.responses["white"]
                self.responses["white"] = None
        else:
            self.colour = {
                x: y for x, y in payload.items() if x in ["red", "green", "blue"]
            }
            if self.responses["colour"]:
                msg = self.responses["colour"]
                self.responses["colour"] = None

        if self.colour != cur_colour:
            changed = True
        if msg:
            await self.controller.enqueue(msg)
        elif changed:
            await self.send_status()
            await self.send_info()
        else:
            if random.randrange(20) == 17:
                await self.send_info()
            else:
                await aio.sleep(0)

    async def handle_mqtt_longpush(self, payload):
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "click",
                    "target": self.controller.type + "." + self.name,
                    "value": (payload and "long") or "single",
                },
            }
        )

    async def handle_mqtt_overpower(self, payload):
        self._overpower = payload
        if self._overpower:
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "alert",
                        "target": self.controller.type + "." + self.name,
                        "value": "overpower",
                    },
                }
            )
        await aio.sleep(0)

    async def handle_mqtt_input_event(self, payload):
        await aio.sleep(0)


SHELLYCLASS = {
    "shellybulb": ShellyB,
    "shellycolorbulb": ShellyCB,
    "ShellyVintage": ShellyV,
    "shellyrgbw2": ShellyRGB,
}


class ShellyBridge(bl.BuddyMQTT):

    """
    This is the bridge application. It will check for the current list  of shelly
    It will report any new bulb
    """

    def __init__(self, defaults={}, descr="Shelly Bulbs Bridge"):
        super().__init__(ShellyB, defaults, descr)
        self.mqtt_topics = ["#"]
        self.mqtt_client = None
        self.config_name = "shelly-bulbs"
        self.noevent = True
        self.infos = {}

    def build_devices_commands(self):

        seencmds = set()
        result = f"""
        <buddyui version="0.1">
            <command  name="{self.subtype}">
         """
        for c in SHELLYCLASS.values():
            light = c(BUILDNAME, BUILDNAME)
            loc = light.xml_names(gen_xml=True)
            for cn, cd in loc.items():
                if cd[0] not in seencmds and cn not in seencmds:
                    result += cd[1] + "\n"
                    if cd[0]:  # Don't add none
                        seencmds.add(cd[0])
                    else:
                        seencmds.add(cn)

        result += """
            </command>
        </buddyui>
        """
        return result

    def lp_prepare(self, desc, parser=None, default={}):
        """

        Whenever overloading this,  set your own dftls for those elements
        that need to be set and saved

        Set things in default to your own defaults (e.g. type and subtype

        """
        parser = super().lp_prepare(desc, parser, default)
        # Now we add ipv6prefix
        parser.add_argument(
            "-u",
            "--update",
            action="store_true",
            default=False,
            help="This shall be the bridge module issueing firmware upgrade commands.",
        )
        return parser

    def local_response_save_configuration(self, msg):
        """
        Here we eflect the changes to the discovery mechanisms
        """
        if self.mqtt_client:
            aio.create_task(self.mqtt_client.disconnect())
            self.mqtt_client = None
            self.mqtt_task["mqtt read"].cancel()
            self.mqtt_task["mqtt read"] = aio.create_task(self.mqtt_reader())

    async def handle_command_update_fw(self, msg):
        if self.bridge_config["update"]:
            await self.mqtt_wqueue.put(("command", b"update_fw"))
        else:
            await aio.sleep(0)

    def build(self, devices):
        for adevid in DEVLIST:
            self.devices += SHELLYCLASS[adevid].from_list(
                [x for x in devices if x["name"].startswith(adevid)]
            )
        if self.bridge_config["update"]:
            self.command_buddy["update_fw"] = {
                "module": self.bridge_config["type"],
                "value": self.bridge_config["subtype"],
                "label": "Update Shellies Firmware",
            }
        for dev in self.devices:
            dev.controller = self
            dev.present = False

    async def global_process_mqtt(self, topic, payload):
        """
        Treat mqtt messages that should not be passed on to devices
        Return True if the message was processed False if it is for devices
        """
        ret = False
        if len(topic.split("/")) == 2 and topic.split("/")[-1] == "announce":
            ret = True
            if reduce(
                lambda x, y: x or y,
                [payload["id"].startswith(z) for z in DEVLIST],
                False,
            ):
                found = False
                _log.debug(f"Announce with {topic} and {payload}")
                for dev in self.devices:
                    if dev.name == payload["id"]:
                        found = True
                        break
                if not found:
                    _log.debug(
                        f"Creating {payload['id']} with {SHELLYCLASS[payload['id'].split('-')[0]]}"
                    )
                    ndev = SHELLYCLASS[payload["id"].split("-")[0]](
                        payload["id"], payload["id"]
                    )
                    ndev.info = payload
                    ndev.controller = self
                    self.pending.append(ndev)
                    await self.enqueue(
                        {
                            "subject": "control" + "." + self.type,
                            "content_type": "request",
                            "content": {
                                "request": "creation",
                                "target": self.type,
                                "value": {
                                    "name": payload["id"],
                                    "nickname": payload["id"],
                                    "subtype": self.subtype,
                                },
                            },
                        }
                    )
        elif topic.split("/")[-1] in [
            "command",
            "set",
        ]:  # Just a command sent to a device.... ignore
            ret = True
        elif not reduce(lambda x, y: x or y, [z in topic for z in DEVLIST], False):
            ret = True
        else:
            pass
            # _log.debug(f"Global with {topic} and {payload}... with {[z in topic for z in DEVLIST]}")
        await aio.sleep(0)
        return ret

    def topic_to_devices(self, topic):
        """
        Given a topic, returns a 2-uple
            - list of names of devices targeted
            - event
        """
        try:
            prefix = topic.split("/")[0].split("-")[0]
            topic = topic.replace(MQTTXTRA[prefix], "")
            lot = topic.split("/")
            lodev = [lot[0]]
            if len(lot) == 1:
                #                _log.debug(f"t to d returns {lodev} for onoff")
                return lodev, "onoff"
            elif lot[-1] == "0":  # Input and longpush for RGBW2
                return lodev, lot[-2]
            #            _log.debug(f"t to d returns {lodev} for {lot[-1]}")
            return lodev, lot[-1]
        except Exception as e:
            _log.debug(f"t to d from {topic} error:{e}")
            return [], "noop"

    async def mqtt_connection(self):
        """
        Overload to do things once the MQTT ibus is connected
        """
        await self.mqtt_wqueue.put(("command", b"announce"))

    #        await self.mqtt_wqueue.put(("command", b'update'))

    def last_rites(self):
        try:
            # Stop the heartbeat
            for dev in self.devices:
                dev.hbtask.cancel()
            super().last_rites()
        except:
            pass


aboutstr = """<p>ShellyBulbBuddy is a bridge talking to WiFi bulbs made by <a href="https://shelly.cloud">Shelly</a> configured
to communicate over MQTT.</p>
<p>The icon used to represent devices has been lifted and adapted from <a href="https://fortawesome.github.io/Font-Awesome">Font Awesome</a>
<i class=\"fa fa-flag-o \">These guys rock!</i>
<p class=\"bu-copyright\">&copy; 2019 Fran&ccedil;ois Wautier</p>
"""
iconstr = """
   <svg class="bu-device-icon" width="60" height="60" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg">
     <path class="bu-shape" d="M1120 576q0 13-9.5 22.5t-22.5 9.5-22.5-9.5-9.5-22.5q0-46-54-71t-106-25q-13 0-22.5-9.5t-9.5-22.5 9.5-22.5
                               22.5-9.5q50 0 99.5 16t87 54 37.5 90zm160 0q0-72-34.5-134t-90-101.5-123-62-136.5-22.5-136.5 22.5-123 62-90
                               101.5-34.5 134q0 101 68 180 10 11 30.5 33t30.5 33q128 153 141 298h228q13-145 141-298 10-11 30.5-33t30.5-33q68-79
                               68-180zM1400 576q0 155-103 268-45 49-74.5 87t-59.5 95.5-34 107.5q47 28 47 82 0 37-25 64 25 27 25 64 0 52-45
                               81 13 23 13 47 0 46-31.5 71t-77.5 25q-20 44-60 70t-87 26-87-26-60-70q-46 0-77.5-25t-31.5-71q0-24 13-47-45-29-45-81
                               0-37 25-64-25-27-25-64 0-54 47-82-4-50-34-107.5t-59.5-95.5-74.5-87q-103-113-103-268 0-99 44.5-184.5t117-142
                               164-89 186.5-32.5 186.5 32.5 164 89 117 142 44.5 184.5z"/>
     <path class="bu-fill" d="M1120 576q0 13-9.5 22.5t-22.5 9.5-22.5-9.5-9.5-22.5q0-46-54-71t-106-25q-13 0-22.5-9.5t-9.5-22.5 9.5-22.5
                              22.5-9.5q50 0 99.5 16t87 54 37.5 90zm160 0q0-72-34.5-134t-90-101.5-123-62-136.5-22.5-136.5 22.5-123 62-90
                              101.5-34.5 134q0 101 68 180 10 11 30.5 33t30.5 33q128 153 141 298h228q13-145 141-298 10-11 30.5-33t30.5-33q68-79
                              68-180z" fill="transparent"/>
    <path class="bu-not-present" fill="#a94442"
           d="M1440 893q0-161-87-295l-754 753q137 89 297 89 111 0 211.5-43.5t173.5-116.5 116-174.5 43-212.5zm-999 299l755-754q-135-91-300-91-148
              0-273 73t-198 199-73 274q0 162 89 299zm1223-299q0 157-61 300t-163.5 246-245 164-298.5 61-298.5-61-245-164-163.5-246-61-300 61-299.5
              163.5-245.5 245-164 298.5-61 298.5 61 245 164 163.5 245.5 61 299.5z"/>
   </svg>
"""


if __name__ == "__main__":
    try:
        bridgectl = ShellyBridge(bridge_default)
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {
                    "about": {"ShellyBulbBuddy": aboutstr},
                    "display": {"light": {SUBTYPE: iconstr}},
                    #            "config name": SUBTYPE+ "-light",
                }
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        bridgectl.last_rites()
        loop.run_until_complete(aio.sleep(3))
        loop.close()
