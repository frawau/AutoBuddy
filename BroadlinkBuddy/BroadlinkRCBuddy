#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application listen for events and process them according
# to a set of rules. Commands and/or state changes may ensue.
#
# Copyright (c) 2017 Fran√ßois Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import argparse
import base64
import sys
import json
import os
import ssl
import logging
import random
import string
import struct
import datetime as dt
import asyncio as aio
import aiobroadlink as aiobl
import buddylib as bl
from functools import partial
import importlib

SUBTYPE = "Broadlink"
__version__ = "1.0"
INFOTIMER = 90  # secs

_log = logging.getLogger(__name__)

blremote_function = """
<buddyui version="0.1">
    <command name="broadlinkrc">
        <controlgroup  type="grouplist" name="proxydevice" label="Create a new device" rteffect="1" >
            <control type="text" name="name" label="Name" length="32" />
            <controlgroup type="choice" name="device" label="Device Type">
                <!-- Insert Here -->
                <!-- End Insert Here -->
                <item value="drape" label="Curtain" />
                <item value="hvac" label="HVAC Device" />
            </controlgroup>
        </controlgroup>
    </command>
</buddyui>
"""

blremote_config = ""

blremote_config_default = {}
bridge_default = {
    "type": "remotec",
    "subtype": SUBTYPE,
    #"proxied": ["av","drape","hvac","tv","pj"],
    "ip": "",
}

PROXIEDLABELS = {
    "av": "Audio/Video device",
    "drape": "Curtains",
    "hvac": "HVAC device",
    "tv": "Television",
    "pj": "Projector"
}


# Utility
def name_to_mac(name):
    global bridgectl
    mac = name.replace(bridgectl.subtype + "-", "")
    return ":".join(a + b for a, b in zip(mac[::2], mac[1::2]))


def mac_to_name(mac):
    global bridgectl
    return bridgectl.subtype + "-" + mac.replace(":", "")



class BroadlinkRC(bl.remotec):

    def __init__(self, name, nickname, subtype=SUBTYPE, did=None):
        super().__init__(name, nickname, subtype, did)
        self.commands = ["send", "learn"]  # List of commands/protocols supported
        self.accesslock = aio.Lock() #Ensure that thing happen one at a time
        self._proxies = {"drape":"Curtains", "hvac":"A/C Devices"}

    def to_broadlink(self, frames, timing):
        if timing == "pulses":
            pulses = frames
        else:
            pulses = self.to_lirc(frames, timing)

        array = bytearray()

        for pulse in pulses:
            pulse = round(pulse * 269 / 8192)  # 32.84ms units

            if pulse < 256:
                array += bytearray(struct.pack(">B", pulse))  # big endian (1-byte)
            else:
                array += bytearray([0x00])  # indicate next number is 2-bytes
                array += bytearray(struct.pack(">H", pulse))  # big endian (2-bytes)

        packet = bytearray([0x26, 0x00])  # 0x26 = IR, 0x00 = no repeats
        packet += bytearray(struct.pack("<H", len(array)))  # little endian byte count
        packet += array
        packet += bytearray([0x0D, 0x05])  # IR terminator

        # Add 0s to make ultimate packet size a multiple of 16 for 128-bit AES encryption.
        remainder = (
            len(packet) + 4
        ) % 16  # rm.send_data() adds 4-byte header (02 00 00 00)
        if remainder:
            packet += bytearray(16 - remainder)

        return packet


    async def local_command_send(self, value, rt, msg):
        try:
            code = value["code"]
            if "timing" in value and value["timing"] != "raw":
                # We got an hex string
                if isinstance(code, str):
                    code = [code]  # single frame
                code = self.to_broadlink(code, value["timing"])

            async with self.accesslock:
                if isinstance(code, str):
                    _log.debug(f"Sending string {code}")
                    resu = await self.conn.send_code(bytes.fromhex(code)) or False
                else:
                    _log.debug(f"Sending hex {code}")
                    resu = await self.conn.send_code(code) or False
                resu = True if resu else False

            msg["content"]["value"]["sent"] = resu
            await self.controller.enqueue(msg)

        except Exception as e:
            _log.debug(f"Could not send IR code: {e}")
            _log.exception(e)
            await aio.sleep(0)


    async def local_command_learn(self, value, rt, msg):

        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "gui alert",
                    "target": self.controller.type + "." + self.name,
                    "value": "Please, do press the buttun you want to learn.",
                },
            }
        )
        async with self.accesslock:

            resu = await self.conn.learn_ir_code() or False
            # resu = await self.conn.send_code(base64.b64decode(code))
            if resu:
                msg["content"]["value"]["code"] = resu.hex()
            await self.controller.enqueue(msg)
            iconsts = {
                "bu-radar1": {"opacity": "0"},
                "bu-radar2": {"opacity": "0"},
                "bu-radar3": {"opacity": "0"},
                "multipart": True,
            }
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": {
                        "event": "status",
                        "target": self.controller.type + "." + self.name,
                        "icon status": iconsts,
                        "value": {},
                    },
                }
            )


    async def phase_2(self):

        await self.controller.enqueue({
            "subject": self.controller.type,
            "content_type": "event",
            "content": {
                "event": "gui alert",
                "target": self.controller.type + "." + self.name,
                "value": "We are locked onto the frequency. Follow the icon and press the buttun you wish to learn.",
            },
        })

        iconsts = {
            "bu-radar1": {**{"opacity": "0"}, **self.icon_colour("learn")},
            "bu-radar2": {**{"opacity": "0"}, **self.icon_colour("learn")},
            "bu-radar3": {**{"opacity": "0.1"}, **self.icon_colour("learn")},
            "multipart": True,
        }
        iconsts["animation"] = self.gen_anim("learn")
        msg = {
            "subject": self.controller.type,
            "content_type": "event",
            "content": {
                "event": "status",
                "target": self.controller.type + "." + self.name,
                "icon status": iconsts,
                "value": {},
            },
        }
        await self.controller.enqueue(msg)

    async def local_command_rflearn(self, value, msg):
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "gui alert",
                    "target": self.controller.type + "." + self.name,
                    "value": "Please, do press continuously a button so we can lock onto its frequency.",
                },
            }
        )

        async with self.accesslock:
            resu = await self.conn.learn_rf_code() or False

        if resu:
            msg["content"]["value"]["code"] = resu.hex()
        await self.controller.enqueue(msg)
        iconsts = {
            "bu-radar1": {"opacity": "0"},
            "bu-radar2": {"opacity": "0"},
            "bu-radar3": {"opacity": "0"},
            "multipart": True,
        }
        await self.controller.enqueue(
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "status",
                    "target": self.controller.type + "." + self.name,
                    "icon status": iconsts,
                    "value": {},
                },
            }
        )



class BroadlinkRCBridge(bl.BuddyBridge):

    """
    This is the bridge application. It will check for the current list  of remote control .
    It will report any new remote control
    """

    def __init__(self):
        super().__init__(
            BroadlinkRC, bridge_default, descr="A bridge controlling Broadlink Remote Control devices."
        )
        self.noevent = True
        self.blproto = None
        self.info_tsk = None

    async def process_event_gui_refresh(self, msg):
        for remotec in self.devices:
            await self.enqueue(
                {
                    "subject": self.type,
                    "content_type": "event",
                    "content": {
                        "event": "presence",
                        "target": self.type + "." + remotec.name,
                        "value": "online",
                        "icon status": {"bu-not-present": {"opacity": 0}},
                    },
                }
            )

    def lp_prepare(self, desc, parser=None, default={}):
        """

        Whenever overloading this,  set your own dftls for those elements
        that need to be set and saved

        Set things in default to your own defaults (e.g. type and subtype

        """
        parser = super().lp_prepare(desc, parser, default)
        # Now we add ipv6prefix
        parser.add_argument(
            "-i",
            "--ip",
            default=bridge_default["ip"],
            help="The IP address used to connect to the Broadlink devices (default to guessing).",
        )

        return parser


    def lp_process_extra(self, opts, default, cfg):
        """
        Check if the IP is set, else guess
        """

        _log.debug(f"Extra set to {cfg}")
        if not cfg["ip"]:
            _log.debug(f"IP set to {cfg['ip']}")
            try:
                import netifaces

                for iface in netifaces.interfaces():
                    alladdr = netifaces.ifaddresses(iface)
                    if netifaces.AF_INET in alladdr:
                        alladdr = alladdr[netifaces.AF_INET]
                        for addr in alladdr:
                            if not addr["addr"].startswith("127."):
                                _log.debug(
                                    "Selecting address {} on {}".format(
                                        addr["addr"], iface
                                    )
                                )
                                cfg["ip"] = addr["addr"]
                                break
                        if cfg["ip"]:
                            break
                if not cfg["ip"]:
                    raise Exception
            except:
                raise Exception(
                    "No IP address was specified. We tried but could not guess it. Make sure netifaces is installed"
                )

    def build(self, devices):
        super().build(devices)
        event_loop = aio.get_running_loop()
        self.blproto = aiobl.BroadlinkProtocol(process=self.dev_register)
        coro = event_loop.create_datagram_endpoint(
            lambda: self.blproto, local_addr=(self.bridge_config["ip"], 0)
        )
        task = aio.create_task(coro)
        disc = aio.create_task(self.blproto.discovery())
        self.info_tsk = aio.create_task(self.send_info())

    def dev_register(self, entity):
        if entity.dev in ["RM", "RM PRO", "RM4", "RM4 PRO"]:
            found = False
            ename = mac_to_name(entity.mac)
            for remotec in self.devices:
                if remotec.name == ename:
                    found = True
                    if "PRO" in entity.dev:
                        remotec.commands = [
                            "learn",
                            "send",
                            "learnrf",
                            "sendrf",
                        ]
                    if "RM4" in entity.dev and entity.cloud:
                        aio.create_task(self.enqueue(
                            {
                                "subject": self.type,
                                "content_type": "event",
                                "content": {
                                    "event": "gui alert",
                                    "target": self.type + "." + ename,
                                    "value": "Warning: Device {} is cloud enabled. It won't respond!".format(
                                        remotec.nickname
                                    ),
                                },
                            }
                        ))
                    remotec.conn = entity
                    remotec.present = True

            if not found:
                newdev = BroadlinkRC(ename,ename,self.subtype)
                if "PRO" in entity.dev:
                    newdev.commands = [
                        "learn",
                        "send",
                        "learnrf",
                        "sendrf",
                    ]
                if "RM4" in entity.dev and entity.cloud:
                    aio.create_task(self.enqueue(
                        {
                            "subject": self.type,
                            "content_type": "event",
                            "content": {
                                "event": "gui alert",
                                "target": self.type + "." + ename,
                                "value": "Warning: Device {} is cloud enabled. It won't respond!".format(
                                    newdev.nickname
                                ),
                            },
                        }
                    ))
                newdev.conn = entity
                newdev.controller = self
                self.pending.append(newdev)
                aio.create_task(self.enqueue(
                    {
                        "subject": "control" + "." + self.type,
                        "content_type": "request",
                        "content": {
                            "request": "creation",
                            "target": self.type,
                            "value": {
                                "name": ename,
                                "nickname": ename,
                                "subtype": self.subtype,
                            },
                        },
                    }
                ))

    def unregister(self, entity):
        for dev in self.devices:
            if dev.name == entity.name:
                if dev.conn:
                    self.blproto.unregister(dev.conn)
                return super().register(dev)

    async def send_info(self, lifx=None):
        await aio.sleep(60)
        while True:
            try:
                for remotec in self.devices:
                    msg = ""
                    prefix = '<div><dl class="dl-horizontal">'
                    for attr,lbl in [("dev","Model"),("ip","Ip Address"), ("mac", "MAC Address"), ("name","Name"),("cloud","Cloud Connection")]:
                        try:
                            val = getattr(remotec.conn,attr)
                            msg += f"{prefix}<dt>{lbl}:</dt><dd>{val}</dd>"
                            prefix = ""
                        except:
                            pass

                    if msg:
                        msg += "</dl></div>"
                        await self.enqueue(
                            {
                                "subject": self.type,
                                "content_type": "event",
                                "content": {
                                    "event": "info",
                                    "target": self.type + "." + remotec.name,
                                    "value": msg,
                                },
                            }
                        )
                await aio.sleep(600)
            except aio.CancelledError:
                _log.debug("Send info is being cancelled.")
                return
            except Exception as e:
                self.log.debug(
                    f"Ooops could not send info: {e}")

    def last_rites(self):
        super().last_rites()
        self.info_tsk.cancel()
        self.blproto.stop_discovery = True

aboutstr = """<p>BroadlinRCBuddy is a bridge managing Broadlink remote control devices. </p>
<p>The icon was designed by lifting an icon from <a href="http://fontawesome.io">Flat Icons - http://flaticon.com</a> and
adding to it parts.
</p>
<p class=\"bu-copyright\">&copy; 2021 Fran&ccedil;ois Wautier</p>
"""


if __name__ == "__main__":
    try:
        bridgectl = BroadlinkRCBridge()
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {
                    "about": {"BroadlinkRCBuddy": aboutstr},
                    "display": {bridgectl.type: {bridgectl.subtype: BroadlinkRC.icon}},
                }
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        bridgectl.last_rites()
        loop.run_until_complete(aio.sleep(10))
        loop.close()

