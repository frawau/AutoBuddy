#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Lifx bulbs.
#
# Copyright © 2021 François Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import random
import buddylib as bl
import asyncio as aio
import aioxiaomi
import logging
import sys
from functools import partial

SUBTYPE = "Yeelight"
CERTFILE = "autobuddy.crt"
__version__ = "1.0"

UDP_BROADCAST_PORT = 56700
BUILDNAME = "FakeYee"
MAXRECONNECT = 1

_log = logging.getLogger(__name__)


def intround(x):
    return int(round(x))


def hsv_to_rgb(hue, sat, val):
    h = hue / 360
    s = sat / 100
    v = val / 100
    if s == 0.0:
        v = round(v * 255)
        return (v, v, v)
    i = int(h * 6.0)  # XXX assume int() truncates!
    f = (h * 6.0) - i
    p, q, t = (
        round(255 * (v * (1.0 - s))),
        round(255 * (v * (1.0 - s * f))),
        round(255 * (v * (1.0 - s * (1.0 - f)))),
    )
    v = round(v * 255)
    i %= 6
    if i == 0:
        return (v, t, p)
    if i == 1:
        return (q, v, p)
    if i == 2:
        return (p, v, t)
    if i == 3:
        return (p, q, v)
    if i == 4:
        return (t, p, v)
    if i == 5:
        return (v, p, q)


xiaomi_config_default = {"refresh": 120, "heartbeat": 60}
bridge_default = {"type": "light", "subtype": SUBTYPE}


class Yeelight(bl.light):
    def __init__(self, name, nickname, conn=None, did=None):
        super().__init__(name, nickname, SUBTYPE, did)
        self.from_bulb = None
        self.conn = None
        self.pending_conn = None
        self.rt_duration = "never"
        self._rt_brightness = -1  # Finicky fellows when in real time
        self._rt_temperature = -1
        self.reconnect_cnt = 0
        self._data_expected = False
        if conn:
            self.add_connection(conn)

    def add_connection(self, conn):
        _log.debug(f"Adding connection for {self.nickname} with {conn.support}")
        self.conn = conn
        self.reconnect_cnt = 0
        if "start_cf" in conn.support:
            self.rt_duration = "no"
        if "set_bright" in conn.support:
            self._brightness_range = [0, 100, 1]
        self._colour_range = "set_hsv" in conn.support or "set_rgb" in conn.support
        if "set_ct_abx" in conn.support:
            self._temperature_range = [1700, 6500, 100]
        else:
            self._temperature_range = [6500, 6500, 0]

        if self.name != BUILDNAME:  # It i a real bulb
            conn.register_callback(self.status_cb)
            if self.from_bulb is None:
                self.from_bulb = aio.Queue()
                aio.create_task(self.reader_task())
            _ = self.set_and_send()
            conn.set_connections(2)  # Open 2 channels to the bulb
            conn.set_queue_limit(10, "adapt")
            conn.activate()
            self.present = True

    def update(self, x):
        """
        Overloaded here
        """
        if self.pending_conn:
            self.add_connection(self.pending_conn)
            self.pending_conn = None

    async def reader_task(self):
        """
        When receiveing messages from the bulb, they are placed on the from_bulb queue
        """
        while True:
            msg = await self.from_bulb.get()
            if msg == "Die Now":
                return
            else:
                await self.controller.enqueue(msg)

    def set_and_send(self, msg=None):
        ret = False
        self._data_expected = False  # reset
        if self.conn.power != self.power:
            ret = True
            self.power = self.conn.power

        colour = self.conn.current_colour
        oldcolour = self.colour
        if "hue" in colour:
            self.colour = {
                "hue": colour["hue"],
                "saturation": colour["saturation"],
                "value": colour["brightness"],
            }
        else:
            self.colour = colour
        if self.colour != oldcolour:
            ret = True
        if msg:
            self.from_bulb.put_nowait(msg)
        elif ret:
            aio.create_task(self.send_status_delayed())

    async def local_command_power(self, value, rt, msg=None):
        _log.debug(f"local power with msg {msg}")
        mypartial = partial(self.set_and_send, msg)
        self._data_expected = True
        if "duration" in value:
            duration = 1000 * int(value["duration"])
            self.conn.set_power(
                value["power"], "smooth", duration, callb=lambda x: mypartial()
            )
        else:
            self.conn.set_power(
                value["power"], callb=lambda x: mypartial(),
            )
        await aio.sleep(0)

    async def local_command_white(self, value, rt, msg=None):
        mypartial = partial(self.set_and_send, msg)
        self._data_expected = True
        if rt:
            if (
                value["temperature"] != self._temperature
                and value["temperature"] != self._rt_temperature
            ):
                self._rt_temperature = value["temperature"]
                self.conn.set_temperature(
                    value["temperature"], callb=lambda x: mypartial()
                )
            elif (
                value["brightness"] != self.brightness
                and value["brightness"] != self._rt_brightness
            ):
                self._rt_brightness = value["brightness"]
                self.conn.set_brightness(
                    value["brightness"], callb=lambda x: mypartial()
                )
        elif "duration" in value and int(value["duration"]):
            duration = 1000 * int(value["duration"])
            self.conn.start_flow(
                1,
                "stop",
                [
                    duration,
                    aioxiaomi.Mode.White.value,
                    value["temperature"],
                    value["brightness"],
                ],
                callb=lambda x: mypartial(),
            )
        else:
            self.conn.set_white_direct(
                value["temperature"], value["brightness"], callb=lambda x: mypartial(),
            )
        await aio.sleep(0)

    async def local_command_colour(self, value, rt, msg=None):
        mypartial = partial(self.set_and_send, msg)
        self._data_expected = True
        if rt:
            self.conn.set_hsv(
                intround(float(value["hue"])),
                intround(float(value["saturation"])),
                "smooth",
            )
            self.conn.set_brightness(
                intround(float(value["value"])), "smooth", callb=lambda x: mypartial()
            )
        elif "duration" in value and int(value["duration"]):
            duration = 1000 * int(value["duration"])
            self.conn.start_flow(
                1,
                "stop",
                [duration, aioxiaomi.Mode.RGB.value]
                + list(hsv_to_rgb(value["hue"], value["saturation"], value["value"])),
                callb=lambda x: mypartial(),
            )
        else:
            if "set_hsv" in self.conn.support:
                self.conn.set_hsv_direct(
                    value["hue"],
                    value["saturation"],
                    value["value"],
                    callb=lambda x: mypartial(),
                )
            else:
                rgb = hsv_to_rgb(value["hue"], value["saturation"], 100)
                rgb = (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]
                self.conn.set_rgb_direct(
                    rgb, value["value"], callb=lambda x: mypartial()
                )
        await aio.sleep(0)

    async def handle_command_pulse(self, value, rt):
        if self.power == "on":
            iconsts = {}
            thiscss = self.icon_colour()["fill"]
            locss = "{ 0% { fill:  " + thiscss + " } "
            myflow = []
            finalcss = "transparent"
            ending = value["ending"]
            actions = value["flow action"]
            totalduration = 0.0
            for action in actions:
                totalduration += float(action["duration"]) * 1000.0
            if ending == "start":
                finalcss = thiscss
            elif ending == "stop":
                for action in actions[::-1]:
                    if action["action"]["selection"] == "sleep":
                        continue

                    if action["action"]["selection"] == "white":
                        finalcss = self.icon_colour(action["action"])["fill"]
                    else:
                        finalcss = self.icon_colour(action["action"]["colour"])["fill"]
                    break
            totaltime = 0.0
            for action in actions:
                totaltime += float(action["duration"]) * 1000.0
                myflow.append(intround(float(action["duration"]) * 1000.0))
                if action["action"]["selection"] == "sleep":
                    myflow.append(7)
                    myflow.append(-1)
                    myflow.append(-1)
                elif action["action"]["selection"] == "white":
                    thiscss = self.icon_colour(action["action"])["fill"]
                    myflow.append(2)
                    myflow.append(int(action["action"]["temperature"]))
                    myflow.append(int(action["action"]["brightness"]))
                else:
                    thiscss = self.icon_colour(action["action"]["colour"])["fill"]
                    myflow.append(1)
                    myflow.append(int(thiscss.strip("#"), base=16))
                    myflow.append(int(action["action"]["colour"]["value"]))

                thisp = int(round((totaltime / totalduration) * 100))
                locss += "%d%% { fill: %s } " % (thisp, thiscss)
            locss += "}"

            repeat = int(value["repeat"])
            prefix = bl.animname()
            anim = "@keyframes " + prefix + self.name + locss
            anim += "\n@-webkit-keyframes " + prefix + self.name + locss
            anim += "\n@-moz-keyframes " + prefix + self.name + locss

            anim += (
                "\n.run-animation-"
                + self.name
                + " { animation-name: "
                + prefix
                + self.name
                + "; animation-duration: %dms" % totalduration
                + "; animation-iteration-count: %d; }" % (repeat)
            )
            iconsts["animation"] = anim
            iconsts["bu-fill"] = {"fill": finalcss}
            tdur = int((totalduration * repeat) / 1000)
            self.hbdelay(tdur)

        else:
            iconsts = {"bu-fill": {"fill": "transparent"}}

        mypartial = partial(
            self.from_bulb.put_nowait,
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "pulse",
                    "target": self.controller.type + "." + self.name,
                    "icon status": iconsts,
                    "value": value,
                },
            },
        )

        self.conn.start_flow(
            repeat * len(actions), ending, myflow, callb=lambda x: mypartial()
        )
        await aio.sleep(0)

    async def handle_command_save_state(self, value, rt):
        self.conn.set_default()
        await aio.sleep(0)

    def hbdelay(self, alen):
        if self.conn.hbtimer < alen:
            self.conn.hbtimer = alen + 5

    def lighthb(self, duration=5):
        try:  # Could happen that conn is None... Maybe a race condition with unregister
            # if True:
            #            _log.debug(f"Heartbeat {self.conn.infosent}")
            if self.conn.hbtimer <= 0:
                self.conn.hbtimer = self.controller.buddy_config["heartbeat"]
                if not self.conn.infosent or random.randrange(50) == 17:
                    aio.create_task(self.send_info())
                    self.conn.infosent = True
                if (
                    "music_on" not in self.conn.properties
                    or self.conn.properties["music_on"] != 1
                ):
                    if (
                        "flowing" not in self.conn.properties
                        or self.conn.properties["flowing"] != 1
                    ):
                        self.conn.get_prop(
                            [
                                "power",
                                "bright",
                                "sat",
                                "hue",
                                "ct",
                                "rgb",
                                "color_mode",
                            ],
                            callb=self.status_cb,
                        )
            else:
                self.conn.hbtimer -= 5
            self.controller.ylhb[self.name] = aio.get_running_loop().call_later(
                duration, partial(self.lighthb, 5)
            )
        except:
            pass

    async def send_status(self):
        """
        Send the current Lifx status
        """
        if not self.present:
            await aio.sleep(0)
            return
        try:
            content = {
                "event": "status",
                "target": self.controller.type + "." + self.name,
                "icon status": {
                    "bu-fill": self.icon_colour(),
                    "bu-not-present": {"opacity": 0},
                },
                "value": {
                    "power": {"power": self.power},
                    "colour": self._colour,
                    "white": {
                        "brightness": self.brightness,
                        "temperature": self.temperature,
                    },
                },
            }
            for x in self.xml_names().values():
                if x is not None:
                    content["value"][x] = "yes"
            await self.controller.enqueue(
                {
                    "subject": self.controller.type,
                    "content_type": "event",
                    "content": content,
                }
            )
        except Exception as e:
            _log.warning(f"Ooops could not send status {e}")

    async def send_info(self):
        # Can be used in callback
        #        _log.debug(f"Sending info for {self.conn.properties}")
        try:
            msg = ""
            prefix = '<div><dl class="dl-horizontal">'
            for x in ["name", "model", "ip_address", "port", "fw_ver", "support"]:
                if x in self.conn.properties:
                    msg += (
                        prefix
                        + "<dt>"
                        + x.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(self.conn.properties[x])
                        + "</dd>"
                    )
                    prefix = ""
                elif getattr(self.conn, x, None):
                    msg += (
                        prefix
                        + "<dt>"
                        + x.replace("_", " ").title()
                        + ":</dt><dd>"
                        + str(getattr(self.conn, x))
                        + "</dd>"
                    )
                    prefix = ""

            if msg:
                msg += "</dl></div>"
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "info",
                            "target": self.controller.type + "." + self.name,
                            "value": msg,
                        },
                    }
                )
        except Exception as e:
            _log.debug(f"Ooops could not send info: {e}")
            await aio.sleep(0)

    def status_cb(self, m=None):
        #        _log.debug(f"Status callback with {self._data_expected}")
        if not self._data_expected:
            self.set_and_send()

    def info_cb(self, lifx=None, resp=None):
        aio.create_task(self.send_info())

    async def reconnect(self, ip, data):
        await aio.sleep(3)
        self.power = "off"
        _log.debug(f"Reconnecting {ip} with {data}")
        try:
            # Let's chexck the bugger is still there
            ping = await aio.create_subprocess_exec("ping", "-q", "-c", "2", ip[0])
            isthere = await ping.wait()
            if isthere:
                #                _log.debug(f"Got {isthere} for ping with {ping.returncode}")
                raise Exception("No ping")
            self.controller.check_newbulb(ip, data)
        except Exception as e:
            # Really bad
            _log.debug(f"Reconnection failed miserably: {e}")
            #            _log.exception(e)
            self.conn = None
            self.reconnect_cnt = MAXRECONNECT + 1


class YeelightBridge(bl.BuddyBridge):

    """
    This is the bridge application. It will check for the current list  of lifx bulb.
    It will report any new bulb
    """

    def __init__(self):
        super().__init__(
            Yeelight,
            bridge_default,
            descr="A bridge controlling Yeelight LED light bulbs",
        )
        self.probelights = None
        self.ylhb = {}
        self.noevent =  True
        # Build the tunable config
        self.buddy_config = xiaomi_config_default
        # Let'sd build the XML
        self.config_buddy.append(
            bl.xml.xml_spinner(
                "refresh",
                label="Check for new devices interval",
                start=30,
                end=3600,
                increment=1,
                postfix="secs",
                default=180,
            )
        )
        self.config_buddy.append(
            bl.xml.xml_spinner(
                "heartbeat",
                label="Requesting status from bulbs",
                start=10,
                end=600,
                increment=10,
                postfix="secs",
                default=60,
            )
        )

    def build_devices_commands(self):
        """
        Build commands for the devices. Here we check all possible commands and
        create them
        """

        class fake:
            def __init__(self):
                self.support = [
                    "set_bright",
                    "set_ct_abx",
                    "start_cf",
                    "set_power",
                    "set_hsv",
                ]

        result = f"""
        <buddyui version="0.1">
            <command  name="{self.subtype}">
         """
        light = Yeelight(BUILDNAME, BUILDNAME, conn=fake())
        loc = light.xml_names(gen_xml=True)
        for cn, cd in loc.items():
            result += cd[1] + "\n"
        # Adding pulse
        result += """
                <controlgroup  type="grouplist" name="pulse" label="Animation" rteffect="1" onlyif="buoicmd_colours::yes">
                    <control type="spinner" name="repeat" label="Repeat" rteffect="1">
                        <start>0</start>
                        <default>1</default>
                        <increment>1</increment>
                    </control>
                    <controlgroup type="choice" name="ending" label="End Action" >
                        <item label="Start Colour" value='start' />
                        <item label="End Colour" value='stop' />
                        <item label="Light Off" value='off' />
                    </controlgroup>
                    <controlgroup type="listmaker"  name="flow action" label="Actions">
                        <control type="text" name="name" label="Name" length="32"/>
                        <control type="spinner" name="duration" label="Duration" rteffect="1">
                            <start>0.01</start>
                            <end>10000</end>
                            <increment>0.1</increment>
                            <decimals>2</decimals>
                            <default>1.0</default>
                            <postfix>secs</postfix>
                        </control>
                        <controlgroup type="choice"  name="action" label="Action">
                            <item value="white" label="White">
                                <control type="slider" name="brightness" label="Brightness">
                                    <start>0</start>
                                    <end>100</end>
                                    <increment>1</increment>
                                </control>
                                <control type="slider" name="temperature" label="Kelvin">
                                    <start>1700</start>
                                    <end>6500</end>
                                    <increment>100</increment>
                                </control>
                            </item>
                            <item value="colour" label="Colour">
                                <controlgroup type="list" name="colour" label="Colour" widget="colourpicker" rteffect="1">
                                    <control type="slider" name="hue" label="Hue" rteffect="1">
                                        <start>0</start>
                                        <end>360</end>
                                        <increment>1</increment>
                                    </control>
                                    <control type="slider" name="saturation" label="Saturation" rteffect="1">
                                        <start>0</start>
                                        <end>100</end>
                                        <increment>1</increment>
                                    </control>
                                    <control type="slider" name="value" label="Brightness" rteffect="1">
                                        <start>0</start>
                                        <end>100</end>
                                        <increment>1</increment>
                                    </control>
                                </controlgroup>
                            </item>
                            <item value="sleep" label="Sleep" />
                        </controlgroup>
                    </controlgroup>
                </controlgroup>
                <controlgroup  type="grouplist" name="save_state" label="Set state as default" rteffect="-1" >
                </controlgroup>
            </command>
        </buddyui>
        """
        return result

    def build(self, devices):
        self.devices = Yeelight.from_list(devices)
        for dev in self.devices:
            dev.controller = self
            dev.present = False
        # Here we have the AutoBuddy bus running, let's start our things
        future = aioxiaomi.start_xiaomi_discovery(self.check_newbulb)
        future.add_done_callback(self.start_broadcast)

    def start_broadcast(self, future):
        probe = future.result()
        self.probelights = probe
        probe.broadcast(2, self.buddy_config["refresh"])

    def check_newbulb(self, address, data):
        # _log.debug(f"New bulb with ip {address},  {address.__class__} and {data}")
        if "id" in data:
            newconn = aioxiaomi.XiaomiBulb(aio.get_event_loop(), data, self)
            newconn.orig_data = data
            lname = self.subtype + "-" + str(newconn.bulb_id)
            for dev in self.devices:
                if dev.name == lname and (dev.conn or dev.pending_conn):
                    del newconn
                    return
            self.newbulb(newconn)

    def newbulb(self, alight):
        lname = self.subtype + "-" + str(alight.bulb_id)
        notseen = True
        alight.hbtimer = 0
        alight.infosent = False
        for light in self.devices:
            if lname == light.name:
                # print(f"Light {alight} is {alight.product},  {dir(alight)}")
                light.add_connection(alight)
                notseen = False
                break
        if notseen:
            newlight = Yeelight(lname, alight.properties["name"] or lname)
            newlight.controller = self
            newlight.pending_conn = alight
            self.pending.append(newlight)
            aio.create_task(
                self.enqueue(
                    {
                        "subject": "control" + "." + self.type,
                        "content_type": "request",
                        "content": {
                            "request": "creation",
                            "target": self.type,
                            "value": {
                                "name": lname,
                                "nickname": newlight.nickname,
                                "subtype": self.subtype,
                            },
                        },
                    }
                )
            )
        else:
            self.ylhb[light.name] = aio.get_running_loop().call_later(
                random.randrange(int(self.buddy_config["heartbeat"])),
                partial(light.lighthb, 5),
            )

    def register(self, alight):
        pass

    def unregister(self, alight):
        """
        Removing disconnecting light bulbs
        """
        _log.debug(f"Unregister {alight}")

        alight_name = self.subtype + "-" + str(alight.bulb_id)
        for light in self.devices:
            if light.name == alight_name:
                light.reconnect_cnt += 1
                if light.reconnect_cnt <= MAXRECONNECT:
                    aio.create_task(
                        light.reconnect(
                            (light.conn.ip_address, light.conn.port),
                            light.conn.orig_data,
                        )
                    )
                try:
                    self.controller.ylhb[alight_name].cancel()
                    # print ("HB Canceled for {}".format(alight.name))
                except:
                    pass
                light.conn = None
                light.present = False
                return
        td = None
        for light in self.pending:
            if light.name == alight_name:
                td = light
                break
        if td:
            self.pending.remove(td)


aboutstr = """<p>XiaomiBuddy is a bridge talking to <a href="https://www.yeelight.com/">Xiaomi Yeelight</a> lights. A library called <a href="https://github.com/frawau/aioxiaomi">aioxiaomi</a>
 is used when communicating with the actual device.</p>
 <p>The icon used to represent Xiaomi devices has been lifted and adapted from <a href="https://fortawesome.github.io/Font-Awesome">Font Awesome</a>
<i class=\"fa fa-flag-o \">These guys rock!</i></p>
<p class=\"bu-copyright\">&copy; 2017 Fran&ccedil;ois Wautier</p>
"""


if __name__ == "__main__":
    try:
        bridgectl = YeelightBridge()
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {
                    "about": {"XiaomiBuddy": aboutstr},
                    "display": {SUBTYPE: Yeelight.icon},
                }
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        for x in bridgectl.devices:
            if x.from_bulb:
                x.from_bulb.put_nowait("Die Now")
                try:
                    bridgectl.ylhb[x.name].cancel()
                except:
                    pass
        bridgectl.last_rites()
        bridgectl.probelights.close()
        loop.run_until_complete(aio.sleep(3))
        loop.close()
