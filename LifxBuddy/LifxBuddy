#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Lifx bulbs.
#
# Copyright © 2021 François Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import random
import buddylib as bl
import asyncio as aio
import aiolifx
import logging
import sys
from functools import partial

SUBTYPE = "Lifx"
CERTFILE = "autobuddy.crt"
__version__ = "1.0"

UDP_BROADCAST_PORT = 56700
BUILDNAME = "FakeLifx"  # Name of Lifx object used when building commands XML
# FEATURES = {
#    y: aiolifx.products.features_map[x] for x, y in aiolifx.products.product_map.items()
# }
FEATURES = aiolifx.products.features_map

_log = logging.getLogger(__name__)


def intround(x):
    return int(round(x))


lifx_config = """
<buddyui version="0.1">
    <configuration  name="lifx">
        <control type="spinner" name="refresh" label="Check for new devices interval">
            <start>30</start>
            <end>3600</end>
            <increment>1</increment>
            <postfix>secs</postfix>
            <default>180</default>
        </control>
        <control type="spinner" name="heartbeat" label="Requesting status from lightbulbs">
            <start>10</start>
            <end>600</end>
            <increment>10</increment>
            <postfix>secs</postfix>
            <default>60</default>
        </control>
    </configuration>
</buddyui>
"""
lifx_config_default = {"refresh": 120, "heartbeat": 60}
bridge_default = {
    "type": "light",
    "subtype": SUBTYPE,
    "ipv6prefix": False,
}


class Lifx(bl.light):
    def __init__(self, name, nickname, subtype=SUBTYPE, conn=None, did=None):
        super().__init__(name, nickname, subtype, did)
        self.from_bulb = None
        self.conn = None
        self.pending_conn = None
        self.rt_duration = "no"
        if conn and conn.product in FEATURES:
            self.add_connection(conn)

    def add_connection(self, conn):
        self.conn = conn
        self._brightness_range = [0, 100, 1]
        self._colour_range = FEATURES[conn.product]["color"]
        if "max_kelvin" in FEATURES[conn.product]:
            if (
                FEATURES[conn.product]["max_kelvin"]
                != FEATURES[conn.product]["min_kelvin"]
            ):
                self._temperature_range = [
                    FEATURES[conn.product]["min_kelvin"],
                    FEATURES[conn.product]["max_kelvin"],
                    100,
                ]
            else:
                self._temperature_range = [
                    FEATURES[conn.product]["min_kelvin"],
                    FEATURES[conn.product]["max_kelvin"],
                    0,
                ]
        else:
            self._temperature_range = [2500, 2500, 0]

        if self.name != BUILDNAME:  # It i a real bulb
            if self.from_bulb is None:
                self.from_bulb = aio.Queue()
                aio.create_task(self.reader_task())
            _ = self.set_and_send()
            self.present = True

    def update(self, x):
        """
        Overloaded here
        """
        if self.pending_conn:
            self.add_connection(self.pending_conn)
            self.pending_conn = None

    @property
    def product(self):
        return aiolifx.products.product_map[self.conn.product]

    async def reader_task(self):
        """
        When receiveing messages from the bulb, they are placed on the from_bulb queue
        """
        while True:
            msg = await self.from_bulb.get()
            if msg == "Die Now":
                return
            else:
                await self.controller.enqueue(msg)

    def set_and_send(self, msg=None):
        ret = False
        if self.conn.power_level:
            if self.power != "on":
                ret = True
                self.power = "on"
                _log.debug(f"{self.nickname} power to on")
        else:
            if self.power == "on":
                ret = True
                self.power = "off"
                _log.debug(f"{self.nickname} power to off")
        colour = self.conn.color
        oldcolour = self.colour
        if (100.0 * colour[1]) / 65365.0 > 1:
            self.colour = {
                "hue": intround((360 * colour[0]) / 65365.0),
                "saturation": intround((100 * colour[1]) / 65365.0),
                "value": intround((100 * colour[2]) / 65365.0),
            }
        else:
            self.colour = {
                "brightness": intround((100 * colour[2]) / 65365.0),
                "temperature": colour[3],
            }
        if self.colour != oldcolour:
            _log.debug(f"{self.nickname} colour to {self.colour} from {oldcolour}")
            ret = True
        if msg:
            self.from_bulb.put_nowait(msg)
        elif ret:
            aio.create_task(self.send_status_delayed())

    async def local_command_power(self, value, rt, msg=None):

        mypartial = partial(self.set_and_send, msg)
        if "duration" in value:
            duration = 1000 * int(value["duration"])
        else:
            duration = 0
        self.conn.set_power(
            (value["power"] == "on" and 1) or 0,
            duration=duration,
            callb=lambda x, y: mypartial(),
        )
        await aio.sleep(0)

    async def local_command_white(self, value, rt, msg=None):
        if "duration" in value:
            duration = 1000 * int(value["duration"])
        else:
            duration = 0
        mypartial = partial(self.set_and_send, msg)
        self.conn.set_color(
            [
                58275,
                0,
                intround((float(value["brightness"]) * 65365.0) / 100.0),
                intround(float(value["temperature"])),
            ],
            duration=duration,
            callb=lambda x, y: mypartial(),
            rapid=rt,
        )
        await aio.sleep(0)

    async def local_command_colour(self, value, rt, msg=None):
        if "duration" in value:
            duration = 1000 * int(value["duration"])
        else:
            duration = 0
        mypartial = partial(self.set_and_send, msg)
        self.conn.set_color(
            [
                intround((float(value["hue"]) * 65535.0) / 360.0),
                intround((float(value["saturation"]) * 65535.0) / 100.0),
                intround((float(value["value"]) * 65535.0) / 100.0),
                3500,
            ],
            duration=duration,
            callb=lambda x, y: mypartial(),
            rapid=rt,
        )
        await aio.sleep(0)

    async def handle_command_pulse(self, value, rt):
        await aio.sleep(0)
        if self.power == "on":
            iconsts = {}
            startcss = self.icon_colour()["fill"]
            endcss = self.icon_colour(force=value["colour"])["fill"]
            trans = "transient" in value and value["transient"] == "on"
            dur = int(float(value["duration"]) * 1000)
            repeat = int(value["repeat"])
            prefix = bl.animname()
            if trans:
                anim = (
                    "@keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  50% { fill: "
                    + endcss
                    + " }  100% { fill: "
                    + startcss
                    + " }}"
                )
                anim += (
                    "\n@-webkit-keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  50% { fill: "
                    + endcss
                    + " }  100% { fill: "
                    + startcss
                    + " }}"
                )
                anim += (
                    "\n@-moz-keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  50% { fill: "
                    + endcss
                    + " }  100% { fill: "
                    + startcss
                    + " }}"
                )
                anim += (
                    "\n@-o-keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  50% { fill: "
                    + endcss
                    + " }  100% { fill: "
                    + startcss
                    + " }}"
                )
                alen = dur
                arep = repeat
                fillcolour = startcss
            else:
                anim = (
                    "@keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  33% { fill: "
                    + endcss
                    + " }  66% { fill: "
                    + startcss
                    + " } 100% { fill: "
                    + endcss
                    + " }}"
                )
                anim += (
                    "\n@-webkit-keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  33% { fill: "
                    + endcss
                    + " }  66% { fill: "
                    + startcss
                    + " } 100% { fill: "
                    + endcss
                    + " }}"
                )
                anim += (
                    "\n@-moz-keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  33% { fill: "
                    + endcss
                    + " }  66% { fill: "
                    + startcss
                    + " } 100% { fill: "
                    + endcss
                    + " }}"
                )
                anim += (
                    "\n@-o-keyframes "
                    + prefix
                    + self.name
                    + " {  0% { fill: "
                    + startcss
                    + " }  33% { fill: "
                    + endcss
                    + " }  66% { fill: "
                    + startcss
                    + " } 100% { fill: "
                    + endcss
                    + " }}"
                )
                alen = intround(dur * 1.5)
                arep = intround(repeat / 1.5) or 1
                fillcolour = endcss
            anim += (
                "\n.run-animation-"
                + self.name
                + " { animation-name: "
                + prefix
                + self.name
                + "; animation-duration: %dms" % alen
                + "; animation-iteration-count: %d; }" % (arep)
            )
            iconsts["animation"] = anim
            iconsts["bu-fill"] = {"fill": fillcolour}
            self.heartbeat_delay((alen * arep) / 1000)

        else:
            iconsts = {"bu-fill": {"fill": "transparent"}}

        mypartial = partial(
            self.from_bulb.put_nowait,
            {
                "subject": self.controller.type,
                "content_type": "event",
                "content": {
                    "event": "pulse",
                    "target": self.controller.type + "." + self.name,
                    "icon status": iconsts,
                    "value": value,
                },
            },
        )

        self.conn.set_waveform(
            {
                "color": [
                    intround((float(value["colour"]["hue"]) * 65535.0) / 360.0),
                    intround((float(value["colour"]["saturation"]) * 65535.0) / 100.0),
                    intround((float(value["colour"]["value"]) * 65535.0) / 100.0),
                    3500,
                ],
                "transient": trans,
                "period": dur,
                "cycles": repeat,
                "skew_ratio": intround((32767 * int(value["balance"])) / 50.0),
                "waveform": value["type"],
            },
            callb=lambda x, y: mypartial(),
        )

    def hbdelay(self, alen):
        if self.conn.hbtimer < alen:
            self.conn.hbtimer = alen + 5

    def lighthb(self, duration=5):
        try:  # Could happen that conn is None... Maybe a race condition with unregister
            # if True:
            # _log.debug(f"Heartbeat for {self.nickname} with {self.conn.hbtimer}")
            if self.conn.hbtimer <= 0:
                self.conn.hbtimer = self.controller.buddy_config["heartbeat"]
                if self.conn.vendor is None:
                    self.conn.get_hostfirmware()
                    self.conn.get_version(callb=self.info_cb)
                    self.conn.infosent = True
                elif not self.conn.infosent or random.randrange(50) == 17:
                    aio.create_task(self.send_info())
                    self.conn.infosent = True
                self.conn.get_color(callb=self.status_cb)
            else:
                self.conn.hbtimer -= 5
            self.controller.lifxhb[self.name] = aio.get_running_loop().call_later(
                duration, partial(self.lighthb, 5)
            )
        except Exception as e:
            _log.debug(f"Heartbeat problem {e}")
            pass

    async def send_info(self):
        # Can be used in callback
        try:
            msg = ""
            prefix = '<div><dl class="dl-horizontal">'
            for x in [
                "label",
                "location",
                "group",
                "product",
                "version",
                "vendor",
                "ip_addr",
                "port",
                "mac_addr",
                "host_firmware_version",
            ]:
                if getattr(self.conn, x):
                    if x == "product":
                        msg += prefix + "<dt>Product:</dt><dd>" + self.product + "</dd>"
                    else:
                        msg += (
                            prefix
                            + "<dt>"
                            + x.replace("_", " ").title()
                            + ":</dt><dd>"
                            + str(getattr(self.conn, x))
                            + "</dd>"
                        )
                    prefix = ""
            if msg:
                msg += "</dl></div>"
                await self.controller.enqueue(
                    {
                        "subject": self.controller.type,
                        "content_type": "event",
                        "content": {
                            "event": "info",
                            "target": self.controller.type + "." + self.name,
                            "value": msg,
                        },
                    }
                )
        except Exception as e:
            _log.debug(f"Ooops could not send info: {e}")
            await aio.sleep(0)

    def status_cb(self, lifx=None, resp=None):
        self.set_and_send()

    def info_cb(self, lifx=None, resp=None):
        aio.create_task(self.send_info())


class LifxBridge(bl.BuddyBridge):

    """
    This is the bridge application. It will check for the current list  of lifx bulb.
    It will report any new bulb
    """

    def __init__(self):
        super().__init__(
            Lifx, bridge_default, descr="A bridge controlling Lifx LED light bulbs"
        )
        self.probelights = None
        self.lifxhb = {}
        # Build the tunable config
        self.buddy_config = lifx_config_default
        self.noevent = True
        # Let'sd build the XML
        self.config_buddy.append(
            bl.xml.xml_spinner(
                "refresh",
                label="Check for new devices interval",
                start=30,
                end=3600,
                increment=1,
                postfix="secs",
                default=180,
            )
        )
        self.config_buddy.append(
            bl.xml.xml_spinner(
                "heartbeat",
                label="Requesting status from bulbs",
                start=10,
                end=600,
                increment=10,
                postfix="secs",
                default=60,
            )
        )

    def build_devices_commands(self):
        """
        Build commands for the devices. Here we check all possible commands and
        create them
        """

        class fake:
            def __init__(self, prod):
                self.product = prod

        seencmds = set()
        result = f"""
        <buddyui version="0.1">
            <command  name="{self.subtype}">
         """
        for x in FEATURES:
            light = Lifx(BUILDNAME, BUILDNAME, conn=fake(x))
            loc = light.xml_names(gen_xml=True)
            for cn, cd in loc.items():
                if cd[0] not in seencmds and cn not in seencmds:
                    result += cd[1] + "\n"
                    if cd[0]:  # Don't add none
                        seencmds.add(cd[0])
                    else:
                        seencmds.add(cn)
        # Adding pulse
        result += """
                <controlgroup  type="grouplist" name="pulse" label="Pulse" rteffect="1">
                    <control type="switch" name="transient" label="End Colour" rteffect="1">
                        <value label="Old">on</value>
                        <value label="New">off</value>
                    </control>
                    <controlgroup type="list" name="colour" label="Colour" widget="colourpicker" rteffect="1">
                        <control type="slider" name="hue" label="Hue" rteffect="1">
                            <start>0</start>
                            <end>360</end>
                            <increment>1</increment>
                        </control>
                        <control type="slider" name="saturation" label="Saturation" rteffect="1">
                            <start>0</start>
                            <end>100</end>
                            <increment>1</increment>
                        </control>
                        <control type="slider" name="value" label="Brightness" rteffect="1">
                            <start>0</start>
                            <end>100</end>
                            <increment>1</increment>
                        </control>
                    </controlgroup>
                    <control type="spinner" name="duration" label="Duration" rteffect="1">
                        <start>0.01</start>
                        <end>300</end>
                        <increment>0.1</increment>
                        <decimals>2</decimals>
                        <default>1.0</default>
                    </control>
                    <control type="spinner" name="repeat" label="Repeat" rteffect="1">
                        <start>1</start>
                        <increment>1</increment>
                    </control>
                    <control  type="slider" name="balance" label="Balance">
                        <start>-50</start>
                        <end>50</end>
                        <increment>1</increment>
                        <default>0</default>
                    </control>
                    <controlgroup type="choice" name="type" label="Type">
                        <item value="0" label="Saw" />
                        <item value="1" label="Sine" />
                        <item value="2" label="Half Sine" />
                        <item value="3" label="Triangle" />
                        <item value="4" label="Pulse" />
                    </controlgroup>
                </controlgroup>
            </command>
        </buddyui>
        """
        return result

    def lp_prepare(self, desc, parser=None, default={}):
        """

        Whenever overloading this,  set your own dftls for those elements
        that need to be set and saved

        Set things in default to your own defaults (e.g. type and subtype

        """
        parser = super().lp_prepare(desc, parser, default)
        # Now we add ipv6prefix
        parser.add_argument(
            "-6",
            "--ipv6prefix",
            default=False,
            help="Connect to Lifx using IPv6 with given /64 prefix (Do not end with colon unless you have less than 64bits).",
        )
        return parser

    def local_response_save_configuration(self, msg):
        """
        Here we eflect the changes to the discovery mechanisms
        """
        aiolifx.DISCOVERY_INTERVAL = self.buddy_config["refresh"]

    def local_response_configuration(self, msg):
        """
        Here we reflect the changes to the discovery mechanisms
        """
        aiolifx.DISCOVERY_INTERVAL = self.buddy_config["refresh"]

    def build(self, devices):
        self.devices = Lifx.from_list(devices)
        for dev in self.devices:
            dev.controller = self
            dev.present = False
        # Here we have the AutoBuddy bus running, let's start our things
        self.probelights = aiolifx.LifxDiscovery(aio.get_running_loop(), self)
        self.probelights.start()

    # This is a call back, so we need the right signature
    def newbulb(self, alight, xx):
        lname = self.subtype + "-" + alight.mac_addr.replace(":", "")
        notseen = True
        alight.hbtimer = 0
        alight.infosent = False
        for light in self.devices:
            if lname == light.name:
                # print(f"Light {alight} is {alight.product},  {dir(alight)}")
                light.add_connection(alight)
                notseen = False
                break
        if notseen:
            newlight = Lifx(lname, alight.label or lname, subtype=self.subtype)
            newlight.controller = self
            newlight.pending_conn = alight
            self.pending.append(newlight)
            aio.create_task(
                self.enqueue(
                    {
                        "subject": "control" + "." + self.type,
                        "content_type": "request",
                        "content": {
                            "request": "creation",
                            "target": self.type,
                            "value": {
                                "name": lname,
                                "nickname": alight.label or lname,
                                "subtype": self.subtype,
                            },
                        },
                    }
                )
            )
        else:
            self.lifxhb[light.name] = aio.get_running_loop().call_later(
                random.randrange(int(self.buddy_config["heartbeat"])),
                partial(light.lighthb, 5),
            )

    def register(self, alight):
        if not isinstance(alight, Lifx):
            _ = alight.get_version()
            _ = alight.get_label()
            _ = alight.get_power()
            _ = alight.get_color(callb=partial(self.newbulb))
        else:
            _log.debug("Registerung a Lifx... Should not have happened")

    def unregister(self, alight):
        """
        Careful here... Both the Lifx and aiolifx.lifx possible here
        """
        if alight in self.pending:
            self.pending.remove(alight)
        else:
            if isinstance(alight, Lifx):
                lname = alight.name
                super().unregister(alight)
            else:
                lname = self.subtype + "-" + alight.mac_addr.replace(":", "")
            try:
                self.lifxhb[lname].cancel()
                # print ("HB Canceled for {}".format(alight.label))
            except:
                pass
            for light in self.devices:
                try:  # HAve to protect, in some rare cases, alight does not have a name attribute yet
                    if light.name == lname:
                        light.present = False
                        light.conn = None
                except:
                    pass
        # Just in case it is one of those spurious disconnect,
        # ask for a probe in 5 to 10 secs
        if self.probelights is not None:
            self.probelights.discovery_countdown = 5


aboutstr = """<p>LifxBuddy is a bridge talking to <a href="http://www.lifx.com">Lifx</a> lights. A library called <a href="https://github.com/frawau/aiolifx">aiolifx</a>
 is used when communicating with the actual device.</p>
<p>The icon used to represent Lifx devices has been lifted and adapted from <a href="https://fortawesome.github.io/Font-Awesome">Font Awesome</a>
<i class=\"fa fa-flag-o \">These guys rock!</i></p>
<p class=\"bu-copyright\">&copy; 2017 Fran&ccedil;ois Wautier</p>
"""


if __name__ == "__main__":
    try:
        bridgectl = LifxBridge()
    except bl.BuddyConfigOnly:
        sys.exit(-1)

    try:
        loop = aio.get_event_loop()
        loop.run_until_complete(
            bridgectl.start(
                {"about": {"LifxBuddy": aboutstr}, "display": {SUBTYPE: Lifx.icon}}
            )
        )
        loop.run_until_complete(bridgectl.future)
    except KeyboardInterrupt:
        print("\n", "Exiting at user's request")
    finally:
        for x in bridgectl.devices:
            if x.from_bulb:
                x.from_bulb.put_nowait("Die Now")
        bridgectl.last_rites()
        for x in bridgectl.lifxhb.values():
            x.cancel()
        bridgectl.probelights.cleanup()
        loop.run_until_complete(aio.sleep(3))
        loop.close()
